{"meta":{"title":"xunhan","subtitle":"博客","description":"这是训瀚的博客","author":"xunhanliu","url":"https://www.xunhanliu.top"},"pages":[{"title":"","date":"2018-07-03T08:16:28.185Z","updated":"2018-07-03T08:16:28.185Z","comments":true,"path":"about/index.html","permalink":"https://www.xunhanliu.top/about/index.html","excerpt":"","text":"关于我从事 WEB 开发，主要开发语言 PHP，熟悉使用 Laravel、ThinkPHP 等主流框架；对 Modern PHP 情有独钟；有一定的代码洁癖。 对服务端、前端、数据分析等技能有所了解。 热爱开源项目、热爱新技术、热爱新事物。 关于工作城市：深圳 关于学习正在往终身学习者前进…近期学习方向：Python (人工智能) 关于座右铭 The Harder You Work, The Luckier You Will Be. (越努力，越幸运) 关于爱好热爱运动，尤其喜爱羽毛球、阅读、电影（Top250）、旅行。 联系我 Home: minhow.com Blog: blog.minhow.com Email: huangminhow@gmail.com GitHub: MinHow WeiBo: MinHow Twitter: MinHow"},{"title":"","date":"2018-07-05T14:45:10.836Z","updated":"2018-07-05T14:45:03.791Z","comments":true,"path":"css/test.css","permalink":"https://www.xunhanliu.top/css/test.css","excerpt":"","text":"#outCSS{ color: #0f0; }"},{"title":"","date":"2018-07-05T21:41:18.475Z","updated":"2018-07-05T21:41:18.475Z","comments":true,"path":"css/tsne-how_use/last.js","permalink":"https://www.xunhanliu.top/css/tsne-how_use/last.js","excerpt":"","text":"(function() { var format = d3.format(\",\"); d3.selectAll(\".tsne-group\").data(figures, function(d) { if(!d) return this.dataset.id; return d.id }) .each(generateFigure) function generateFigure(figure) { var FIGURE = figure.id var dis = d3.select(this) var original = dis.append(\"div\").classed(\"original\", true) original.append(\"div\") .classed(\"image\", true) .append(\"img\") .classed(\"tsne-plot\", true) .attr(\"src\", \"assets/figure_\" + FIGURE + \"_\" + \"original.png\"); original.append(\"h3\").classed(\"caption\", true).text(\"Original\") // examples var runners = dis.selectAll(\".runner\").data(figure.examples) .enter().append(\"div\").classed(\"runner\", true) if(!figure.noclick) { runners .classed(\"clickable\", true) .on(\"click\", function(d) { d3.selectAll(\".runner\").classed(\"selected\", false) updateStateFromFigure(figure, d, this); d3.select(this).classed(\"selected\", true) }); } else { runners.classed(\"no-click\", true) } runners.append(\"div\") .classed(\"image\", true) .append(\"img\") .attr(\"src\", function(d,i) { return \"assets/figure_\" + FIGURE + \"_\" + d.id + \".png\" }); if(!figure.noclick) { runners.append(\"i\") .classed(\"material-icons\", true) .text(\"open_in_browser\") } var caption = runners.append(\"div\").classed(\"caption\", true); caption.append(\"div\").text(function(d) { return \"Perplexity: \" + format(d.perplexity); }) caption.append(\"div\").text(function(d) { return \"Step: \" + format(d.step); }) } })() function nodeFromString(str) { var div = document.createElement(\"div\"); div.innerHTML = str; return div.firstChild; } function make_hover_css(pos) { var pretty = window.innerWidth > 600; var padding = pretty? 18 : 12; var outer_padding = pretty ? 18 : 0; var bbox = document.querySelector(\"body\").getBoundingClientRect(); var left = pos[0] - bbox.left, top = pos[1] - bbox.top; var width = Math.min(window.innerWidth-2*outer_padding, 648); left = Math.min(left, window.innerWidth-width-outer_padding); width = width - 2*padding; return (`position: absolute; background-color: #FFF; opacity: 0.95; max-width: ${width}px; top: ${top}px; left: ${left}px; border: 1px solid rgba(0, 0, 0, 0.25); padding: ${padding}px; border-radius: ${pretty? 3 : 0}px; box-shadow: 0px 2px 10px 2px rgba(0, 0, 0, 0.2); z-index: ${1e6};`); } function DtHoverBox(div_id) { this.div = document.querySelector(\"#\"+div_id); this.visible = false; this.bindDivEvents(); DtHoverBox.box_map[div_id] = this; } DtHoverBox.box_map = {}; DtHoverBox.get_box = function get_box(div_id) { if (div_id in DtHoverBox.box_map) { return DtHoverBox.box_map[div_id]; } else { return new DtHoverBox(div_id); } } DtHoverBox.prototype.show = function show(pos){ this.visible = true; this.div.setAttribute(\"style\", make_hover_css(pos) ); for (var box_id in DtHoverBox.box_map) { var box = DtHoverBox.box_map[box_id]; if (box != this) box.hide(); } } DtHoverBox.prototype.showAtNode = function showAtNode(node){ var bbox = node.getBoundingClientRect(); this.show([bbox.right, bbox.bottom]); } DtHoverBox.prototype.hide = function hide(){ this.visible = false; if (this.div) this.div.setAttribute(\"style\", \"display:none\"); if (this.timeout) clearTimeout(this.timeout); } DtHoverBox.prototype.stopTimeout = function stopTimeout() { if (this.timeout) clearTimeout(this.timeout); } DtHoverBox.prototype.extendTimeout = function extendTimeout(T) { //console.log(\"extend\", T) var this_ = this; this.stopTimeout(); this.timeout = setTimeout(function(){this_.hide();}.bind(this), T); } // Bind events to a link to open this box DtHoverBox.prototype.bind = function bind(node) { if (typeof node == \"string\"){ node = document.querySelector(node); } node.addEventListener(\"mouseover\", function(){ if (!this.visible) this.showAtNode(node); this.stopTimeout(); }.bind(this)); node.addEventListener(\"mouseout\", function(){this.extendTimeout(250);}.bind(this)); node.addEventListener(\"touchstart\", function(e) { if (this.visible) { this.hide(); } else { this.showAtNode(node); } // Don't trigger body touchstart event when touching link e.stopPropagation(); }.bind(this)); } DtHoverBox.prototype.bindDivEvents = function bindDivEvents(){ // For mice, same behavior as hovering on links this.div.addEventListener(\"mouseover\", function(){ if (!this.visible) this.showAtNode(node); this.stopTimeout(); }.bind(this)); this.div.addEventListener(\"mouseout\", function(){this.extendTimeout(250);}.bind(this)); // Don't trigger body touchstart event when touching within box this.div.addEventListener(\"touchstart\", function(e){e.stopPropagation();}); // Close box when touching outside box document.body.addEventListener(\"touchstart\", function(){this.hide();}.bind(this)); } var hover_es = document.querySelectorAll(\"span[data-hover-ref]\"); hover_es = [].slice.apply(hover_es); hover_es.forEach(function(e,n){ var ref_id = e.getAttribute(\"data-hover-ref\"); DtHoverBox.get_box(ref_id).bind(e); })"},{"title":"","date":"2018-07-05T21:24:40.842Z","updated":"2018-07-05T21:24:40.842Z","comments":true,"path":"css/tsne-how_use/main.css","permalink":"https://www.xunhanliu.top/css/tsne-how_use/main.css","excerpt":"","text":"#playground { overflow: hidden; font-family: 'Open Sans', sans-serif; border-top: 1px solid rgba(0, 0, 0, 0.1); /*border-bottom: 1px solid rgba(0, 0, 0, 0.1);*/ margin-top: 36px; padding: 36px 0 0 0; /*background: #fcfcfc;*/ z-index: 1000; } #playground * { box-sizing: border-box; } #playground.modal { position: fixed; left: 10px; right: 10px; top: 50px; } /* Playground Canvas */ #playground-canvas { float: left; width: 55%; } #playground-canvas canvas { width: 100%; } /* Data Menu */ #data-menu { /*float: left;*/ /*width: 25%*/ width: 40%; float: left; margin-bottom: 24px; overflow: hidden; margin-left: 5%; } #data-menu .demo-data { cursor: pointer; position: relative; font-size: 10px; line-height: 1.2em; box-sizing: border-box; float: left; margin: 2px; padding: 4px; width: calc(33% - 4px); background: white; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 4px; box-shadow: 0 0 3px rgba(0, 0, 0, 0.08); } @media(min-width: 480px) { #data-menu .demo-data { width: calc(25% - 8px); padding: 8px; margin: 4px; } } @media(min-width: 768px) { #data-menu .demo-data { width: calc(16.5% - 8px); padding: 8px; margin: 4px; } } #data-menu .demo-data:hover { border: 1px solid rgba(0, 0, 0, 0.2); } #data-menu .demo-data.selected::after { content: \"\"; border: 2px solid rgba(70, 130, 180, 0.8); width: 100%; height: 100%; position: absolute; top: 0; left: 0; box-sizing: border-box; border-radius: 4px; } #data-menu .demo-data span { display: none; } #data-menu .demo-data:hover canvas { opacity: 1; } #data-menu .demo-data canvas { width: 100%; opacity: 0.3; } #data-menu .demo-data.selected canvas { opacity: 1; } /* Data Details */ #data-details { position: relative; } @media(min-width: 768px) { #data-details { width: 40%; float: right; } } #data-details #data-controls { width: 40%; float: right; position: relative; overflow: hidden; font-size: 13px; } @media(min-width: 768px) { #data-details #data-controls { width: 50%; margin-right: 10%; float: left; } } #data-details #play-controls { margin-bottom: 18px; overflow: hidden; position: relative; } #data-details #play-controls button { cursor: pointer; outline: none; border-radius: 50%; background: steelblue; color: white; width: 25%; margin-right: 5%; padding-top: 25%; padding-bottom: 0; border: none; float: left; position: relative; } #play-controls i { display: block; position: absolute; top: 50%; left: 0; width: 100%; height: 36px; font-size: 24px; line-height: 0; } @media(min-width: 768px) { #play-controls i { font-size: 30px; } } #play-controls #play-pause i { display: none; position: absolute; } #play-controls #play-pause.paused i:nth-child(1) { display: block; } #play-controls #play-pause.playing i:nth-child(2) { display: block; } #steps-display { float: left; text-align: center; width: 25%; line-height: 1.5em; font-size: 13px; } @media(min-width: 1024px) { #steps-display { font-size: 16px; line-height: 1.6em; } } #data-details #data-description { width: 50%; margin-right: 10%; float: right; font-size: 14px; line-height: 1.6em; } @media(min-width: 768px) { #data-details #data-description { width: 40%; float: left; margin-right: 0; } } /* Options 主图1*/ #data-details #options { float: left; padding-left: 36px; font-size: 13px; line-height: 1.5em; width: 45%; } #data-details input { display: block; width: 100%; margin: 8px 0 16px 0; } #options #data-options { width: 45%; margin-left: 4px; } #options #tsne-options { width: 45%; margin-left: 4px; } #data-details #share { margin-top: 8px; display: block; color: rgba(0, 0, 0, 0.4); text-decoration: none; font-size: 12px; } #data-details #share:hover { text-decoration: underline; } #data-details #share i { line-height: 0px; position: relative; top: 7px; }"},{"title":"","date":"2018-07-05T21:39:16.269Z","updated":"2018-07-05T21:39:16.269Z","comments":true,"path":"css/tsne-how_use/main.js","permalink":"https://www.xunhanliu.top/css/tsne-how_use/main.js","excerpt":"","text":"// This depends on playground.js having setup the GLOBAL object function runTrayState() { // Set up t-SNE and start it running. var state = GLOBALS.trayState; var points = state.demo.generator.apply(null, state.demoParams); var canvas = d3.select(\"#tray-content canvas\").node() // if there was already a playground demo going, lets destroy it and make a new one if(GLOBALS.trayDemo) { GLOBALS.trayDemo.destroy(); delete GLOBALS.trayDemo; } GLOBALS.trayDemo = demoMaker(points, canvas, state, function(step) { d3.select(\"#tray-controls .step\").text(step); if(step >= state.stepLimit && !GLOBALS.trayUnpausedBefore) { setTrayRunning(false) } }) GLOBALS.trayUnpausedBefore = false; setTrayRunning(true); } function updateTraySliders() { // we regenerate all the sliders from scratch // we modify the global tray state when a slider is modified var state = GLOBALS.trayState; var dataSliders = d3.select('#tray-data-sliders'); dataSliders.html(''); state.demo.options.map(function(option, i) { var value = state.demoParams[i]; var slider = makeTraySlider(dataSliders.node(), option.name, option.min, option.max, value, function() { // when this one updates we change the appropriate state GLOBALS.trayState.demoParams[i] = +slider.value runTrayState(); }); }); var tsneSliders = d3.select('#tray-tsne-sliders'); tsneSliders.html(''); var perpSlider = makeTraySlider(tsneSliders.node(), \"Perplexity\", 1, 100, state.perplexity, function() { GLOBALS.trayState.perplexity = perpSlider.value runTrayState(); }); var epsSlider = makeTraySlider(tsneSliders.node(), \"Epsilon\", 1, 20, state.epsilon, function() { GLOBALS.trayState.epsilon = epsSlider.value runTrayState(); }); } function makeTraySlider(container, name, min, max, start, changeCallback) { var dis = d3.select(container) dis.append(\"span\").classed(\"slider-label-\" + name, true) .text(name + ' ') var value = dis.append(\"span\").classed(\"slider-value-\" + name, true) .text(start) var slider = dis.append(\"input\") .attr(\"type\", \"range\") .attr(\"min\", min) .attr(\"max\", max) .attr(\"value\", start) .on(\"change\", changeCallback) .on(\"input\", function() { value.text(slider.node().value); }) return slider.node(); } /* Activate the tray */ function updateStateFromFigure(figure, example, el) { var y = el.getBoundingClientRect().top; var demo = demosByName[figure.dataset]; var state = { demo: demos[demo.index], demoParams: figure.params.map(function(d) { return d}), perplexity: example.perplexity, epsilon: example.epsilon, stepLimit: example.step } GLOBALS.trayState = state; runTrayState() updateTraySliders() d3.select(\"#tray-container\").classed(\"modal\", true) GLOBALS.trayOpen = true; } d3.select(\"body\").on(\"keydown\", function() { if(d3.event.keyCode === 27) { setTrayRunning(false) d3.select(\"#tray-container\").classed(\"modal\", false); d3.selectAll(\".runner\").classed(\"selected\", false); } }) d3.select(\"#tray-close\").on(\"click\", function() { setTrayRunning(false); GLOBALS.trayOpen = false; d3.select(\"#tray-container\").classed(\"modal\", false) d3.selectAll(\".runner\").classed(\"selected\", false); }) /* Tray Controls */ var trayPlay = d3.select(\"#tray-controls .play-pause\") function setTrayRunning(r) { GLOBALS.running = r; if (GLOBALS.running) { GLOBALS.trayDemo.unpause(); trayPlay .classed(\"playing\", true) .classed(\"paused\", false); } else { GLOBALS.trayDemo.pause(); trayPlay .classed(\"playing\", false) .classed(\"paused\", true); } } // Hook up play / pause / restart buttons. trayPlay.on(\"click\", function() { GLOBALS.trayUnpausedBefore = true; setTrayRunning(!GLOBALS.running); }); var trayRestart = d3.select(\"#tray-controls .restart\") .on(\"click\", function() { runTrayState(); }) d3.select(window).on(\"scroll.tray\", function() { if(GLOBALS.trayOpen) { if(scrollY < 1000) { setTrayRunning(false); GLOBALS.trayOpen = false; d3.select(\"#tray-container\").classed(\"modal\", false); d3.selectAll(\".runner\").classed(\"selected\", false); } } });"},{"title":"","date":"2018-07-05T13:13:33.754Z","updated":"2018-07-05T13:06:29.131Z","comments":true,"path":"css/tsne-how_use/material-icons.css","permalink":"https://www.xunhanliu.top/css/tsne-how_use/material-icons.css","excerpt":"","text":"@font-face { font-family: 'Material Icons'; font-style: normal; font-weight: 400; src: local('Material Icons'), local('MaterialIcons-Regular'), url(MaterialIcons-Regular.woff) format('woff'); } .material-icons { font-family: 'Material Icons'; font-weight: normal; font-style: normal; font-size: 24px; /* Preferred icon size */ display: inline-block; line-height: 1; text-transform: none; letter-spacing: normal; word-wrap: normal; white-space: nowrap; direction: ltr; /* Support for all WebKit browsers. */ -webkit-font-smoothing: antialiased; /* Support for Safari and Chrome. */ text-rendering: optimizeLegibility; /* Support for Firefox. */ -moz-osx-font-smoothing: grayscale; /* Support for IE. */ font-feature-settings: 'liga'; }"},{"title":"","date":"2018-07-05T13:13:26.826Z","updated":"2018-07-05T13:06:25.663Z","comments":true,"path":"js/tsne-how_use/demo-configs.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/demo-configs.js","excerpt":"","text":"/** * @fileoverview Synthetic data sets for t-SNE demo and visualizations, * along with some utility functions. */ // Copyright 2018 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. if(typeof require != \"undefined\") { // hack for loading from generator var d3 = require('./d3.min.js') } // Euclidean distance. function dist(a, b) { var d = 0; for (var i = 0; i < a.length; i++) { d += (a[i] - b[i]) * (a[i] - b[i]); } return Math.sqrt(d); } // Gaussian generator, mean = 0, std = 1. var normal = d3.randomNormal(); // Create random Gaussian vector. function normalVector(dim) { var p = []; for (var j = 0; j < dim; j++) { p[j] = normal(); } return p; } // Scale the given vector. function scale(vector, a) { for (var i = 0; i < vector.length; i++) { vector[i] *= a; } } // Add two vectors. function add(a, b) { var n = a.length; var c = []; for (var i = 0; i < n; i++) { c[i] = a[i] + b[i]; } return c; } // A point with color info. var Point = function(coords, color) { this.coords = coords; this.color = color || '#039'; }; // Adds colors to points depending on 2D location of original. function addSpatialColors(points) { var xExtent = d3.extent(points, function(p) {return p.coords[0]}); var yExtent = d3.extent(points, function(p) {return p.coords[1]}); var xScale = d3.scaleLinear().domain(xExtent).range([0, 255]); var yScale = d3.scaleLinear().domain(yExtent).range([0, 255]); points.forEach(function(p) { var c1 = ~~xScale(p.coords[0]); var c2 = ~~yScale(p.coords[1]); p.color = 'rgb(20,' + c1 + ',' + c2 + ')'; }); } // Convenience function to wrap 2d arrays as Points, using a default // color scheme. function makePoints(originals) { var points = originals.map(function(p) {return new Point(p);}); addSpatialColors(points); return points; } // Creates distance matrix for t-SNE input. function distanceMatrix(points) { var matrix = []; var n = points.length; for (var i = 0; i < n; i++) { for (var j = 0; j < n; j++) { matrix.push(dist(points[i].coords, points[j].coords)); } } return matrix; } // Data in shape of 2D grid. function gridData(size) { var points = []; for (var x = 0; x < size; x++) { for (var y = 0; y < size; y++) { points.push([x, y]); } } return makePoints(points); } // Gaussian cloud, symmetric, of given dimension. function gaussianData(n, dim) { var points = []; for (var i = 0; i < n; i++) { var p = normalVector(dim); points.push(new Point(p)); } return points; } // Elongated Gaussian ellipsoid. function longGaussianData(n, dim) { var points = []; for (var i = 0; i < n; i++) { var p = normalVector(dim); for (var j = 0; j < dim; j++) { p[j] /= (1 + j); } points.push(new Point(p)); } return points; } // Return a color for the given angle. function angleColor(t) { var hue = ~~(300 * t / (2 * Math.PI)); return 'hsl(' + hue + ',50%,50%)'; } // Data in a 2D circle, regularly spaced. function circleData(numPoints) { var points = []; for (var i = 0; i < numPoints; i++) { var t = 2 * Math.PI * i / numPoints; points.push(new Point([Math.cos(t), Math.sin(t)], angleColor(t))); } return points; } // Random points on a 2D circle. function randomCircleData(numPoints) { var points = []; for (var i = 0; i < numPoints; i++) { var t = 2 * Math.PI * Math.random(); points.push(new Point([Math.cos(t), Math.sin(t)], angleColor(t))); } return points; } // Clusters arranged in a circle. function randomCircleClusterData(numPoints) { var points = []; for (var i = 0; i < numPoints; i++) { var t = 2 * Math.PI * i / numPoints;//Math.random(); var color = angleColor(t); for (var j = 0; j < 20; j++) { var x = Math.cos(t) + .01 * normal(); var y = Math.sin(t) + .01 * normal(); points.push(new Point([x, y], color)); } } return points; } // Two 2D clusters of different sizes. function twoDifferentClustersData2D(n) { var points = []; for (var i = 0; i < n; i++) { points.push(new Point([10 * normal(), 10 * normal()], '#039')); points.push(new Point([100 + normal(), normal()], '#f90')); } return points; } // Two clusters of the same size. function twoClustersData(n, dim) { dim = dim || 50; var points = []; for (var i = 0; i < n; i++) { points.push(new Point(normalVector(dim), '#039')); var v = normalVector(dim); v[0] += 10; points.push(new Point(v, '#f90')); } return points; } // Two differently sized clusters, of arbitrary dimensions. function twoDifferentClustersData(n, dim, scale) { dim = dim || 50; scale = scale || 10; var points = []; for (var i = 0; i < n; i++) { points.push(new Point(normalVector(dim), '#039')); var v = normalVector(dim); for (var j = 0; j < dim; j++) { v[j] /= scale; } v[0] += 20; points.push(new Point(v, '#f90')); } return points; } // Three clusters, at different distances from each other, in 2D function threeClustersData2d(n) { var points = []; for (var i = 0; i < n; i++) { points.push(new Point([normal(), normal()], '#039')); points.push(new Point([10 + normal(), normal()], '#f90')); points.push(new Point([50 + normal(), normal()], '#6a3')); } return points; } // Three clusters, at different distances from each other, in any dimension. function threeClustersData(n, dim) { dim = dim || 50; var points = []; for (var i = 0; i < n; i++) { var p1 = normalVector(dim); points.push(new Point(p1, '#039')); var p2 = normalVector(dim); p2[0] += 10; points.push(new Point(p2, '#f90')); var p3 = normalVector(dim); p3[0] += 50; points.push(new Point(p3, '#6a3')); } return points; } // One tiny cluster inside of a big cluster. function subsetClustersData(n, dim) { dim = dim || 2; var points = []; for (var i = 0; i < n; i++) { var p1 = normalVector(dim); points.push(new Point(p1, '#039')); var p2 = normalVector(dim); scale(p2, 50); points.push(new Point(p2, '#f90')); } return points; } // Data in a rough simplex. function simplexData(n, noise) { noise = noise || 0.5; var points = []; for (var i = 0; i < n; i++) { var p = []; for (var j = 0; j < n; j++) { p[j] = i == j ? 1 + noise * normal() : 0; } points.push(new Point(p)); } return points; } // Uniform points from a cube. function cubeData(n, dim) { var points = []; for (var i = 0; i < n; i++) { var p = []; for (var j = 0; j < dim; j++) { p[j] = Math.random(); } points.push(new Point(p)); } return points; } // Points in two unlinked rings. function unlinkData(n) { var points = []; function rotate(x, y, z) { var u = x; var cos = Math.cos(.4); var sin = Math.sin(.4); var v = cos * y + sin * z; var w = -sin * y + cos * z; return [u, v, w]; } for (var i = 0; i < n; i++) { var t = 2 * Math.PI * i / n; var sin = Math.sin(t); var cos = Math.cos(t); // Ring 1. points.push(new Point(rotate(cos, sin, 0), '#f90')); // Ring 2. points.push(new Point(rotate(3 + cos, 0, sin), '#039')); } return points; } // Points in linked rings. function linkData(n) { var points = []; function rotate(x, y, z) { var u = x; var cos = Math.cos(.4); var sin = Math.sin(.4); var v = cos * y + sin * z; var w = -sin * y + cos * z; return [u, v, w]; } for (var i = 0; i < n; i++) { var t = 2 * Math.PI * i / n; var sin = Math.sin(t); var cos = Math.cos(t); // Ring 1. points.push(new Point(rotate(cos, sin, 0), '#f90')); // Ring 2. points.push(new Point(rotate(1 + cos, 0, sin), '#039')); } return points; } // Points in a trefoil knot. function trefoilData(n) { var points = []; for (var i = 0; i < n; i++) { var t = 2 * Math.PI * i / n; var x = Math.sin(t) + 2 * Math.sin(2 * t); var y = Math.cos(t) - 2 * Math.cos(2 * t); var z = -Math.sin(3 * t); points.push(new Point([x, y, z], angleColor(t))); } return points; } // Two long, linear clusters in 2D. function longClusterData(n) { var points = []; var s = .03 * n; for (var i = 0; i < n; i++) { var x1 = i + s * normal(); var y1 = i + s * normal(); points.push(new Point([x1, y1], '#039')); var x2 = i + s * normal() + n / 5; var y2 = i + s * normal() - n / 5; points.push(new Point([x2, y2], '#f90')); } return points; } // Mutually orthogonal steps. function orthoCurve(n) { var points = []; for (var i = 0; i < n; i++) { var coords = []; for (var j = 0; j < n; j++) { coords[j] = j < i ? 1 : 0; } var t = 1.5 * Math.PI * i / n; points.push(new Point(coords, angleColor(t))); } return points; } // Random walk function randomWalk(n, dim) { var points = []; var current = []; for (var i = 0; i < dim; i++) { current[i] = 0; } for (var i = 0; i < n; i++) { var step = normalVector(dim); var next = current.slice(); for (var j = 0; j < dim; j++) { next[j] = current[j] + step[j]; } var t = 1.5 * Math.PI * i / n; points.push(new Point(next, angleColor(t))); current = next; } return points; } // Random jump: a random walk with // additional noise added at each step. function randomJump(n, dim) { var points = []; var current = []; for (var i = 0; i < dim; i++) { current[i] = 0; } for (var i = 0; i < n; i++) { var step = normalVector(dim); var next = add(step, current.slice()); var r = normalVector(dim); scale(r, Math.sqrt(dim)); var t = 1.5 * Math.PI * i / n; var coords = add(r, next); points.push(new Point(coords, angleColor(t))); current = next; } return points; } /** * @fileoverview Demo configuration for t-SNE playground. */ var demos = [ { name: 'Grid', description: 'A square grid with equal spacing between points. ' + 'Try convergence at different sizes.', options: [ { name: 'Points Per Side', min: 2, max: 20, start: 10, } ], generator: gridData }, { name: 'Two Clusters', description: 'Two clusters with equal numbers of points.', options: [ { name: 'Points Per Cluster', min: 1, max: 100, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, } ], generator: twoClustersData }, { name: 'Three Clusters', description: 'Three clusters with equal numbers of points, but at ' + 'different distances from each other. Cluster distances are ' + 'only apparent at certain perplexities', options: [ { name: 'Points Per Cluster', min: 1, max: 100, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, } ], generator: threeClustersData }, { name: 'Two Different-Sized Clusters', description: 'Two clusters with equal numbers of points, but different ' + 'variances within the clusters. Cluster separation depends on perplexity.', options: [ { name: 'Points Per Cluster', min: 1, max: 100, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, }, { name: 'Scale', min: 1, max: 10, start: 5, } ], generator: twoDifferentClustersData }, { name: 'Two Long Linear Clusters', description: 'Two sets of points, arranged in parallel lines that ' + 'are close to each other. Note curvature of lines.', options: [ { name: 'Points Per Cluster', min: 1, max: 100, start: 50, } ], generator: longClusterData }, { name: 'Cluster In Cluster', description: 'A dense, tight cluster inside of a wide, sparse cluster. ' + 'Perplexity makes a big difference here.', options: [ { name: 'Points Per Cluster', min: 1, max: 100, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, } ], generator: subsetClustersData }, { name: 'Circle (Evenly Spaced)', description: 'Points evenly distributed in a circle. ' + 'Hue corresponds to angle in the circle.', options: [ { name: 'Number Of Points', min: 1, max: 100, start: 50, } ], generator: circleData }, { name: 'Circle (Randomly Spaced)', description: 'Points randomly distributed in a circle. ' + 'Hue corresponds to angle in the circle.', options: [ { name: 'Number Of Points', min: 1, max: 100, start: 50, } ], generator: randomCircleData }, { name: 'Gaussian Cloud', description: 'Points in a unit Gaussian distribution. ' + 'Data is entirely random, so any visible subclusters are ' + 'not statistically significant', options: [ { name: 'Number Of Points', min: 1, max: 500, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, } ], generator: gaussianData }, { name: 'Ellipsoidal Gaussian Cloud', description: 'Points in an ellipsoidal Gaussian distribution. ' + ' Dimension n has variance 1/n. Elongation is visible in plot.', options: [ { name: 'Number Of Points', min: 1, max: 500, start: 50, }, { name: 'Dimensions', min: 1, max: 100, start: 2, } ], generator: longGaussianData }, { name: 'Trefoil Knot', description: 'Points arranged in 3D, following a trefoil knot. ' + 'Different runs may give different results.', options: [ { name: 'Number Of Points', min: 1, max: 200, start: 50, } ], generator: trefoilData }, { name: 'Linked Rings', description: 'Points arranged in 3D, on two linked circles. ' + 'Different runs may give different results.', options: [ { name: 'Number Of Points', min: 1, max: 200, start: 50, } ], generator: linkData }, { name: 'Unlinked Rings', description: 'Points arranged in 3D, on two unlinked circles', options: [ { name: 'Number Of Points', min: 1, max: 200, start: 50, } ], generator: unlinkData }, { name: 'Orthogonal Steps', description: 'Points related by mutually orthogonal steps. ' + 'Very similar to a random walk.', options: [ { name: 'Number Of Points', min: 1, max: 500, start: 50, } ], generator: orthoCurve }, { name: 'Random Walk', description: 'Random (Gaussian) walk. ' + 'Smoother than you might think.', options: [{ name: 'Number Of Points', min: 1, max: 1000, start: 100, }, { name: 'Dimension', min: 1, max: 1000, start: 100, } ], generator: randomWalk }, { name: 'Random Jump', description: 'Random (Gaussian) Jump', options: [ { name: 'Number Of Points', min: 1, max: 1000, start: 100, }, { name: 'Dimension', min: 1, max: 1000, start: 100, } ], generator: randomJump }, { name: 'Equally Spaced', description: 'A set of points, where distances between all pairs of ' + 'points are the same in the original space.', options: [ { name: 'Number Of Points', min: 2, max: 100, start: 50, } ], generator: simplexData }, { name: 'Uniform Distribution', description: 'Points uniformly distributed in a unit cube.', options: [ { name: 'Number Of Points', min: 2, max: 200, start: 50, }, { name: 'Dimensions', min: 1, max: 10, start: 3, } ], generator: cubeData } ]; var demosByName = {} demos.forEach(function(d, i) { d.index = i; demosByName[d.name] = d; }) if(typeof module != \"undefined\") module.exports = { demos: demos, demosByName: demosByName, distanceMatrix: distanceMatrix, Point: Point };"},{"title":"","date":"2018-07-05T13:13:33.697Z","updated":"2018-07-05T13:06:26.122Z","comments":true,"path":"js/tsne-how_use/figure-configs.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/figure-configs.js","excerpt":"","text":"var figures = [ { id: \"01\", params: [50, 2], dataset: \"Two Clusters\", no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"02\", params: [50, 2], dataset: \"Two Clusters\", no3d: true, examples: [ { id: \"01\", perplexity: 30, epsilon: 10, dim: 2, step: 10 }, { id: \"02\", perplexity: 30, epsilon: 10, dim: 2, step: 20 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 60}, { id: \"04\", perplexity: 30, epsilon: 10, dim: 2, step: 120 }, { id: \"05\", perplexity: 30, epsilon: 10, dim: 2, step: 1000 }, ] }, { id: \"03\", params: [75, 2], dataset: 'Two Different-Sized Clusters', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"04\", params: [50, 2], dataset: 'Three Clusters', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"05\", params: [200, 2], dataset: 'Three Clusters', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"06\", params: [500, 100], dataset: 'Gaussian Cloud', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"07\", params: [100, 50], dataset: 'Ellipsoidal Gaussian Cloud', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"08\", params: [75, 2], dataset: 'Two Long Linear Clusters', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"09\", params: [75, 50], dataset: 'Cluster In Cluster', no3d: true, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"10\", params: [100], dataset: 'Linked Rings', no3d: false, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"11\", params: [150], dataset: 'Trefoil Knot', no3d: false, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 5, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 30, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 100, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"12\", params: [100], dataset: 'Trefoil Knot', no3d: false, examples: [ { id: \"01\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 2, epsilon: 10, dim: 2, step: 5000 }, ] }, { id: \"13\", params: [100], dataset: 'Trefoil Knot', no3d: false, examples: [ { id: \"01\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"02\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"03\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"04\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, { id: \"05\", perplexity: 50, epsilon: 10, dim: 2, step: 5000 }, ] }, ] if(typeof module != \"undefined\") module.exports = figures;"},{"title":"","date":"2018-07-05T13:13:26.735Z","updated":"2018-07-05T13:06:24.856Z","comments":true,"path":"js/tsne-how_use/tsne.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/tsne.js","excerpt":"","text":"'use strict'; /** @license * The MIT License (MIT) * Copyright (c) 2015 Andrej Karpathy * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ //goog.provide('tsnejs'); /** * @type {string} */ //tsnejs.REVISION = 'ALPHA'; var tsnejs = {} // utility function var assert = function(condition, message) { if (!condition) { throw message || 'Assertion failed'; } }; // syntax sugar var getopt = function(opt, field, defaultval) { if (opt.hasOwnProperty(field)) { return opt[field]; } else { return defaultval; } }; // return 0 mean unit standard deviation random number var return_v = false; var v_val = 0.0; var gaussRandom = function(rng) { if (return_v) { return_v = false; return v_val; } var u = 2 * rng() - 1; var v = 2 * rng() - 1; var r = u * u + v * v; if (r == 0 || r > 1) return gaussRandom(rng); var c = Math.sqrt(-2 * Math.log(r) / r); v_val = v * c; // cache this for next function call for efficiency return_v = true; return u * c; }; // return random normal number var randn = function(rng, mu, std) { return mu + gaussRandom(rng) * std; }; // utilitity that creates contiguous vector of zeros of size n var zeros = function(n) { if (typeof(n) === 'undefined' || isNaN(n)) { return []; } if (typeof ArrayBuffer === 'undefined') { // lacking browser support var arr = new Array(n); for (var i = 0; i < n; i++) { arr[i] = 0; } return arr; } else { return new Float64Array(n); // typed arrays are faster } }; // utility that returns 2d array filled with random numbers from generator rng var randn2d = function(n, d, rng) { var x = []; for (var i = 0; i < n; i++) { var xhere = []; for (var j = 0; j < d; j++) { xhere.push(randn(rng, 0.0, 1e-4)); } x.push(xhere); } return x; }; // utility that returns 2d array filled with value s var arrayofs = function(n, d, s) { var x = []; for (var i = 0; i < n; i++) { var xhere = []; for (var j = 0; j < d; j++) { xhere.push(s); } x.push(xhere); } return x; }; // compute L2 distance between two vectors var L2 = function(x1, x2) { var D = x1.length; var d = 0; for (var i = 0; i < D; i++) { var x1i = x1[i]; var x2i = x2[i]; d += (x1i - x2i) * (x1i - x2i); } return d; }; // compute pairwise distance in all vectors in X var xtod = function(X) { var N = X.length; var dist = zeros(N * N); // allocate contiguous array for (var i = 0; i < N; i++) { for (var j = i + 1; j < N; j++) { var d = L2(X[i], X[j]); dist[i * N + j] = d; dist[j * N + i] = d; } } return dist; }; // compute (p_{i|j} + p_{j|i})/(2n) var d2p = function(D, perplexity, tol) { var Nf = Math.sqrt(D.length); // this better be an integer var N = Math.floor(Nf); assert(N === Nf, 'D should have square number of elements.'); var Htarget = Math.log(perplexity); // target entropy of distribution var P = zeros(N * N); // temporary probability matrix var prow = zeros(N); // a temporary storage compartment for (var i = 0; i < N; i++) { var betamin = -Infinity; var betamax = Infinity; var beta = 1; // initial value of precision var done = false; var maxtries = 50; // perform binary search to find a suitable precision beta // so that the entropy of the distribution is appropriate var num = 0; while (!done) { //debugger; // compute entropy and kernel row with beta precision var psum = 0.0; for (var j = 0; j < N; j++) { var pj = Math.exp(- D[i * N + j] * beta); if (i === j) { pj = 0; } // we dont care about diagonals prow[j] = pj; psum += pj; } // normalize p and compute entropy var Hhere = 0.0; for (var j = 0; j < N; j++) { var pj = prow[j] / psum; prow[j] = pj; if (pj > 1e-7) Hhere -= pj * Math.log(pj); } // adjust beta based on result if (Hhere > Htarget) { // entropy was too high (distribution too diffuse) // so we need to increase the precision for more peaky distribution betamin = beta; // move up the bounds if (betamax === Infinity) { beta = beta * 2; } else { beta = (beta + betamax) / 2; } } else { // converse case. make distrubtion less peaky betamax = beta; if (betamin === -Infinity) { beta = beta / 2; } else { beta = (beta + betamin) / 2; } } // stopping conditions: too many tries or got a good precision num++; if (Math.abs(Hhere - Htarget) < tol) { done = true; } if (num >= maxtries) { done = true; } } // copy over the final prow to P at row i for (var j = 0; j < N; j++) { P[i * N + j] = prow[j]; } } // end loop over examples i // symmetrize P and normalize it to sum to 1 over all ij var Pout = zeros(N * N); var N2 = N * 2; for (var i = 0; i < N; i++) { for (var j = 0; j < N; j++) { Pout[i * N + j] = Math.max((P[i * N + j] + P[j * N + i]) / N2, 1e-100); } } return Pout; }; // helper function function sign(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; } /** * @param {?Object} opt Options. * @constructor */ var tSNE = function(opt) { opt = opt || {}; this.perplexity = getopt(opt, 'perplexity', 30); this.dim = getopt(opt, 'dim', 2); // by default 2-D tSNE this.epsilon = getopt(opt, 'epsilon', 10); // learning rate this.rng = getopt(opt, 'rng', Math.random); this.iter = 0; }; tSNE.prototype = { // this function takes a set of high-dimensional points // and creates matrix P from them using gaussian kernel initDataRaw: function(X) { var N = X.length; var D = X[0].length; assert(N > 0, ' X is empty? You must have some data!'); assert(D > 0, ' X[0] is empty? Where is the data?'); var dists = xtod(X); // convert X to distances using gaussian kernel this.P = d2p(dists, this.perplexity, 1e-4); // attach to object this.N = N; // back up the size of the dataset this.initSolution(); // refresh this }, // this function takes a fattened distance matrix and creates // matrix P from them. // D is assumed to be provided as an array of size N^2. initDataDist: function(D) { var N = Math.sqrt(D.length); this.P = d2p(D, this.perplexity, 1e-4); this.N = N; this.initSolution(); // refresh this }, // (re)initializes the solution to random initSolution: function() { // generate random solution to t-SNE this.Y = randn2d(this.N, this.dim, this.rng); // the solution this.gains = arrayofs(this.N, this.dim, 1.0); // step gains // to accelerate progress in unchanging directions this.ystep = arrayofs(this.N, this.dim, 0.0); // momentum accumulator this.iter = 0; }, // return pointer to current solution getSolution: function() { return this.Y; }, // perform a single step of optimization to improve the embedding step: function() { this.iter += 1; var N = this.N; var cg = this.costGrad(this.Y); // evaluate gradient var cost = cg.cost; var grad = cg.grad; // perform gradient step var ymean = zeros(this.dim); for (var i = 0; i < N; i++) { for (var d = 0; d < this.dim; d++) { var gid = grad[i][d]; var sid = this.ystep[i][d]; var gainid = this.gains[i][d]; // compute gain update var newgain = sign(gid) === sign(sid) ? gainid * 0.8 : gainid + 0.2; if (newgain < 0.01) newgain = 0.01; // clamp this.gains[i][d] = newgain; // store for next turn // compute momentum step direction var momval = this.iter < 250 ? 0.5 : 0.8; var newsid = momval * sid - this.epsilon * newgain * grad[i][d]; this.ystep[i][d] = newsid; // remember the step we took // step! this.Y[i][d] += newsid; ymean[d] += this.Y[i][d]; // accumulate mean so that we // can center later } } // reproject Y to be zero mean for (var i = 0; i < N; i++) { for (var d = 0; d < this.dim; d++) { this.Y[i][d] -= ymean[d] / N; } } //if(this.iter%100===0) console.log('iter ' + this.iter + ', //cost: ' + cost); return cost; // return current cost }, // for debugging: gradient check debugGrad: function() { var N = this.N; var cg = this.costGrad(this.Y); // evaluate gradient var cost = cg.cost; var grad = cg.grad; var e = 1e-5; for (var i = 0; i < N; i++) { for (var d = 0; d < this.dim; d++) { var yold = this.Y[i][d]; this.Y[i][d] = yold + e; var cg0 = this.costGrad(this.Y); this.Y[i][d] = yold - e; var cg1 = this.costGrad(this.Y); var analytic = grad[i][d]; var numerical = (cg0.cost - cg1.cost) / (2 * e); console.log(i + ',' + d + ': gradcheck analytic: ' + analytic + ' vs. numerical: ' + numerical); this.Y[i][d] = yold; } } }, // return cost and gradient, given an arrangement costGrad: function(Y) { var N = this.N; var dim = this.dim; // dim of output space var P = this.P; var pmul = this.iter < 100 ? 4 : 1; // trick that helps with local optima // compute current Q distribution, unnormalized first var Qu = zeros(N * N); var qsum = 0.0; for (var i = 0; i < N; i++) { for (var j = i + 1; j < N; j++) { var dsum = 0.0; for (var d = 0; d < dim; d++) { var dhere = Y[i][d] - Y[j][d]; dsum += dhere * dhere; } var qu = 1.0 / (1.0 + dsum); // Student t-distribution Qu[i * N + j] = qu; Qu[j * N + i] = qu; qsum += 2 * qu; } } var cost = 0.0; var grad = []; for (var i = 0; i < N; i++) { var gsum = new Array(dim); // init grad for point i for (var d = 0; d < dim; d++) { gsum[d] = 0.0; } for (var j = 0; j < N; j++) { var normedProb = Math.max(Qu[i * N + j] / qsum, 1e-100); cost += - P[i * N + j] * Math.log(normedProb); // accumulate cost var premult = 4 * (pmul * P[i * N + j] - normedProb) * Qu[i * N + j]; for (var d = 0; d < dim; d++) { gsum[d] += premult * (Y[i][d] - Y[j][d]); } } grad.push(gsum); } return {cost: cost, grad: grad}; } }; tsnejs.tSNE = tSNE; // export tSNE class if(typeof module != \"undefined\") module.exports = tsnejs"},{"title":"","date":"2018-07-05T13:13:26.814Z","updated":"2018-07-05T13:06:27.132Z","comments":true,"path":"js/tsne-how_use/playground.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/playground.js","excerpt":"","text":"/** * @fileoverview Demo that helps explain what t-SNE is doing. * In particular, shows how various geometries translate to a 2D map, * and lets you play with the perplexity hyperparameter. * * None of this is optimized code, because it doesn't seem necessary * for the small cases we're considering. */ // Copyright 2018 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // Global variable for whether we should keep optimizing. var playgroundThread = 0; var GLOBALS = { playgroundDemo: null, // the object to control running the playground simulation trayDemo: null, // the object to control running the tray simulation running: true, unpausedBefore: false, stepLimit: 5000, state: {}, showDemo: null, perplexitySlider: null, epsilonSlider: null, } main(); // Main entry point. function main() { // Set state from hash. var format = d3.format(\",\"); function setStateFromParams() { var params = {}; window.location.hash.substring(1).split('&').forEach(function(p) { var tokens = p.split('='); params[tokens[0]] = tokens[1]; }); function getParam(key, fallback) { return params[key] === undefined ? fallback : params[key]; } GLOBALS.state = { perplexity: +getParam('perplexity', 10), epsilon: +getParam('epsilon', 5), demo: +getParam('demo', 0), demoParams: getParam('demoParams', '20,2').split(',').map(Number) }; } setStateFromParams(); // Utility function for creating value sliders. function makeSlider(container, name, min, max, start) { var dis = d3.select(container) dis.append(\"span\").classed(\"slider-label-\" + name, true) .text(name + ' ') var value = dis.append(\"span\").classed(\"slider-value-\" + name, true) .text(start) var slider = dis.append(\"input\") .attr(\"type\", \"range\") .attr(\"min\", min) .attr(\"max\", max) .attr(\"value\", start) .on(\"change\", updateParameters) .on(\"input\", function() { value.text(slider.node().value); }) return slider.node(); } // Create menu of possible demos. var menuDiv = d3.select(\"#data-menu\"); var dataMenus = menuDiv.selectAll(\".demo-data\") .data(demos) .enter().append(\"div\") .classed(\"demo-data\", true) .on(\"click\", function(d,i) { showDemo(i); }); dataMenus.append(\"canvas\") .attr(\"width\", 150) .attr(\"height\", 150) .each(function(d,i) { var demo = demos[i]; var params = [demo.options[0].start] if(demo.options[1]) params.push(demo.options[1].start) var points = demo.generator.apply(null, params); var canvas = d3.select(this).node() visualize(points, canvas, null, null) }); dataMenus.append(\"span\") .text(function(d) { return d.name}); // Set up t-SNE UI. var tsneUI = document.getElementById('tsne-options'); var perplexitySlider = makeSlider(tsneUI, 'Perplexity', 2, 100, GLOBALS.state.perplexity); var epsilonSlider = makeSlider(tsneUI, 'Epsilon', 1, 20, GLOBALS.state.epsilon); GLOBALS.perplexitySlider = perplexitySlider GLOBALS.epsilonSlider = epsilonSlider // Controls for data options. var optionControls; var demo; function updateParameters() { GLOBALS.state.demoParams = optionControls.map(function(s) {return s.value;}); GLOBALS.state.perplexity = perplexitySlider.value; GLOBALS.state.epsilon = epsilonSlider.value; d3.select(\"#share\").style(\"display\", \"\") .attr(\"href\", \"#\" + generateHash()) runState(); } function generateHash() { function stringify(map) { var s = ''; for (key in map) { s += '&' + key + '=' + map[key]; } return s.substring(1); } //window.location.hash = stringify(GLOBALS.state); return stringify(GLOBALS.state); } function runState() { // Set up t-SNE and start it running. var points = demo.generator.apply(null, GLOBALS.state.demoParams); var canvas = document.getElementById('output'); // if there was already a playground demo going, lets destroy it and make a new one if(GLOBALS.playgroundDemo) { GLOBALS.playgroundDemo.destroy(); delete GLOBALS.playgroundDemo; } //runPlayground(points, canvas, GLOBALS.state, function(step) { GLOBALS.playgroundDemo = demoMaker(points, canvas, GLOBALS.state, function(step) { d3.select(\"#step\").text(format(step)); if(step >= GLOBALS.stepLimit && !GLOBALS.unpausedBefore) { setRunning(false) } }) GLOBALS.unpausedBefore = false; setRunning(true); } var playPause = document.getElementById('play-pause'); function setRunning(r) { GLOBALS.running = r; GLOBALS.playgroundRunning = r; if (GLOBALS.running) { GLOBALS.playgroundDemo.unpause(); playPause.setAttribute(\"class\", \"playing\") } else { GLOBALS.playgroundDemo.pause(); playPause.setAttribute(\"class\", \"paused\") } } // Hook up play / pause / restart buttons. playPause.onclick = function() { GLOBALS.unpausedBefore = true; setRunning(!GLOBALS.running); }; document.getElementById('restart').onclick = updateParameters; // Show a given demo. GLOBALS.showDemo = showDemo; function showDemo(index, initializeFromState) { GLOBALS.state.demo = index; demo = demos[index]; // Show description of demo data. //document.querySelector('#data-description span').textContent = demo.description; d3.select(\"#data-description span\").text(demo.description) // Create UI for the demo data options. var dataOptionsArea = document.getElementById('data-options'); dataOptionsArea.innerHTML = ''; optionControls = demo.options.map(function(option, i) { var value = initializeFromState ? GLOBALS.state.demoParams[i] : option.start; return makeSlider(dataOptionsArea, option.name, option.min, option.max, value); }); menuDiv.selectAll(\".demo-data\") .classed(\"selected\", false) .filter(function(d,i) { return i === index }) .classed(\"selected\", true) updateParameters(); } // run initial demo; setTimeout(function() { showDemo(GLOBALS.state.demo, true); // hide the share link initially d3.select(\"#share\").style(\"display\", \"none\") },1); d3.select(window).on(\"popstate\", function() { setTimeout(function() { //updateParameters(); setStateFromParams(); showDemo(GLOBALS.state.demo, true) },1) }) d3.select(window).on(\"scroll.playground\", function() { if(scrollY > 1000) { if(GLOBALS.playgroundRunning) { setRunning(false); } } else { if(!GLOBALS.playgroundRunning) { // setRunning(true) } } }) }"},{"title":"","date":"2018-07-05T13:13:26.799Z","updated":"2018-07-05T13:06:26.581Z","comments":true,"path":"js/tsne-how_use/visualize.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/visualize.js","excerpt":"","text":"// Copyright 2018 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. if(typeof require != \"undefined\") { // hack for loading from generator var d3 = require('./d3.min.js') } // Helper function to draw a circle. // TODO: replace with canvas blitting for web rendering function circle(g, x, y, r) { g.beginPath(); g.arc(x, y, r, 0, 2 * Math.PI); g.fill(); g.stroke(); } // Visualize the given points with the given message. // If \"no3d\" is set, ignore the 3D cue for size. function visualize(points, canvas, message, no3d) { var width = canvas.width; var height = canvas.height; var g = canvas.getContext('2d'); g.fillStyle = 'white'; g.fillRect(0, 0, width, height); var xExtent = d3.extent(points, function(p) {return p.coords[0]}); var yExtent = d3.extent(points, function(p) {return p.coords[1]}); var zExtent = d3.extent(points, function(p) {return p.coords[2]}); var zScale = d3.scaleLinear().domain(zExtent).range([2, 10]); var centerX = (xExtent[0] + xExtent[1]) / 2; var centerY = (yExtent[0] + yExtent[1]) / 2; var scale = Math.min(width, height) / Math.max(xExtent[1] - xExtent[0], yExtent[1] - yExtent[0]); scale *= .9; // Leave a little margin. g.strokeStyle = 'rgba(255,255,255,.5)'; var is3d = !no3d && points[0].coords.length > 2; var index = []; var n = points.length; if (is3d) { for (var i = 0; i < n; i++) { index[i] = i; } index.sort(function(a, b) { return d3.ascending(points[a].coords[2], points[b].coords[2]); }); } for (var i = 0; i < n; i++) { var p = is3d ? points[index[i]] : points[i]; g.fillStyle = p.color; var x = (p.coords[0] - centerX) * scale + width / 2; var y = -(p.coords[1] - centerY) * scale + height / 2; var r = is3d ? zScale(p.coords[2]) : 4; circle(g, x, y, r); } if (message) { g.fillStyle = '#000'; g.font = '24pt Lato'; g.fillText(message, 8, 34); } } if(typeof module != \"undefined\") module.exports = { visualize: visualize }"},{"title":"","date":"2018-07-05T13:13:26.775Z","updated":"2018-07-05T13:06:26.594Z","comments":true,"path":"js/tsne-how_use/figures.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/figures.js","excerpt":"","text":"/* Configurations and utility functions for figures */ // Copyright 2018 Google LLC // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. if(typeof require != \"undefined\") { // hack for loading from generator var d3 = require('./d3.min.js') var visualize = require('./visualize.js').visualize var tsnejs = require('./tsne.js') var demoConfigs = require('./demo-configs.js') var distanceMatrix = demoConfigs.distanceMatrix var Point = demoConfigs.Point } var FIGURES = { width: 150, height: 150, downscaleWidth: 300, downscaleHeight: 300, } function getPoints(demo, params) { if(!params) { params = [demo.options[0].start] if(demo.options[1]) params.push(demo.options[1].start) } var points = demo.generator.apply(null, params); return points; } function renderDemoInitial(demo, params, canvas) { visualize(points, canvas, null, null) } /* var demoTimescale = d3.scaleLinear() .domain([0, 200, 6000]) .range([20, 10, 0]) */ var timescale = d3.scaleLinear() .domain([0, 20, 50, 100, 200, 6000]) .range([60, 30, 20, 10, 0]); function demoMaker(points, canvas, options, stepCb) { var demo = {}; var paused = false; var step = 0; var chunk = 1; var frameId; var tsne = new tsnejs.tSNE(options); var dists = distanceMatrix(points); tsne.initDataDist(dists); function iterate() { if(paused) return; // control speed at which we iterate if(step >= 200) chunk = 10; for(var k = 0; k < chunk; k++) { tsne.step(); ++step; } //inform the caller about the current step stepCb(step) // update the solution and render var solution = tsne.getSolution().map(function(coords, i) { return new Point(coords, points[i].color); }); visualize(solution, canvas, \"\"); //removed message //control the loop. var timeout = timescale(step) setTimeout(function() { frameId = window.requestAnimationFrame(iterate); }, timeout) } demo.pause = function() { if(paused) return; // already paused paused = true; window.cancelAnimationFrame(frameId) } demo.unpause = function() { if(!paused) return; // already unpaused paused = false; iterate(); } demo.paused = function() { return paused; } demo.destroy = function() { demo.pause(); delete demo; } iterate(); return demo; } function runDemoSync(points, canvas, options, stepLimit, no3d) { var tsne = new tsnejs.tSNE(options); var dists = distanceMatrix(points); tsne.initDataDist(dists); var step = 0; for(var k = 0; k < stepLimit; k++) { if(k % 100 === 0) console.log(\"step\", step) tsne.step(); ++step; } var solution = tsne.getSolution().map(function(coords, i) { return new Point(coords, points[i].color); }); visualize(solution, canvas, \"\", no3d); //removed message return step; } if(typeof module != \"undefined\") module.exports = { demoMaker: demoMaker, runDemoSync: runDemoSync, getPoints: getPoints, FIGURES: FIGURES }"},{"title":"","date":"2018-07-06T16:43:20.316Z","updated":"2018-07-06T16:43:20.316Z","comments":true,"path":"js/tsne-how_use/d3.min.js","permalink":"https://www.xunhanliu.top/js/tsne-how_use/d3.min.js","excerpt":"","text":"// https://d3js.org Version 4.13.0. Copyright 2018 Mike Bostock. (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (factory((global.d3 = global.d3 || {}))); }(this, (function (exports) { 'use strict'; var version = \"4.13.0\"; function ascending(a, b) { return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; } function bisector(compare) { if (compare.length === 1) compare = ascendingComparator(compare); return { left: function(a, x, lo, hi) { if (lo == null) lo = 0; if (hi == null) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid; } return lo; }, right: function(a, x, lo, hi) { if (lo == null) lo = 0; if (hi == null) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1; } return lo; } }; } function ascendingComparator(f) { return function(d, x) { return ascending(f(d), x); }; } var ascendingBisect = bisector(ascending); var bisectRight = ascendingBisect.right; var bisectLeft = ascendingBisect.left; function pairs(array, f) { if (f == null) f = pair; var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n); while (i < n) pairs[i] = f(p, p = array[++i]); return pairs; } function pair(a, b) { return [a, b]; } function cross(values0, values1, reduce) { var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0; if (reduce == null) reduce = pair; for (i0 = i = 0; i0 < n0; ++i0) { for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) { values[i] = reduce(value0, values1[i1]); } } return values; } function descending(a, b) { return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN; } function number(x) { return x === null ? NaN : +x; } function variance(values, valueof) { var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0; if (valueof == null) { while (++i < n) { if (!isNaN(value = number(values[i]))) { delta = value - mean; mean += delta / ++m; sum += delta * (value - mean); } } } else { while (++i < n) { if (!isNaN(value = number(valueof(values[i], i, values)))) { delta = value - mean; mean += delta / ++m; sum += delta * (value - mean); } } } if (m > 1) return sum / (m - 1); } function deviation(array, f) { var v = variance(array, f); return v ? Math.sqrt(v) : v; } function extent(values, valueof) { var n = values.length, i = -1, value, min, max; if (valueof == null) { while (++i < n) { // Find the first comparable value. if ((value = values[i]) != null && value >= value) { min = max = value; while (++i < n) { // Compare the remaining values. if ((value = values[i]) != null) { if (min > value) min = value; if (max < value) max = value; } } } } } else { while (++i < n) { // Find the first comparable value. if ((value = valueof(values[i], i, values)) != null && value >= value) { min = max = value; while (++i < n) { // Compare the remaining values. if ((value = valueof(values[i], i, values)) != null) { if (min > value) min = value; if (max < value) max = value; } } } } } return [min, max]; } var array = Array.prototype; var slice = array.slice; var map = array.map; function constant(x) { return function() { return x; }; } function identity(x) { return x; } function sequence(start, stop, step) { start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step; var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n); while (++i < n) { range[i] = start + i * step; } return range; } var e10 = Math.sqrt(50); var e5 = Math.sqrt(10); var e2 = Math.sqrt(2); function ticks(start, stop, count) { var reverse, i = -1, n, ticks, step; stop = +stop, start = +start, count = +count; if (start === stop && count > 0) return [start]; if (reverse = stop < start) n = start, start = stop, stop = n; if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return []; if (step > 0) { start = Math.ceil(start / step); stop = Math.floor(stop / step); ticks = new Array(n = Math.ceil(stop - start + 1)); while (++i < n) ticks[i] = (start + i) * step; } else { start = Math.floor(start * step); stop = Math.ceil(stop * step); ticks = new Array(n = Math.ceil(start - stop + 1)); while (++i < n) ticks[i] = (start - i) / step; } if (reverse) ticks.reverse(); return ticks; } function tickIncrement(start, stop, count) { var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power); return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1); } function tickStep(start, stop, count) { var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1; if (error >= e10) step1 *= 10; else if (error >= e5) step1 *= 5; else if (error >= e2) step1 *= 2; return stop < start ? -step1 : step1; } function sturges(values) { return Math.ceil(Math.log(values.length) / Math.LN2) + 1; } function histogram() { var value = identity, domain = extent, threshold = sturges; function histogram(data) { var i, n = data.length, x, values = new Array(n); for (i = 0; i < n; ++i) { values[i] = value(data[i], i, data); } var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds. if (!Array.isArray(tz)) { tz = tickStep(x0, x1, tz); tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive } // Remove any thresholds outside the domain. var m = tz.length; while (tz[0] x1) tz.pop(), --m; var bins = new Array(m + 1), bin; // Initialize bins. for (i = 0; i 0 ? tz[i - 1] : x0; bin.x1 = i < m ? tz[i] : x1; } // Assign data to bins by value, ignoring any outside the domain. for (i = 0; i < n; ++i) { x = values[i]; if (x0 = value) { max = value; while (++i < n) { // Compare the remaining values. if ((value = values[i]) != null && value > max) { max = value; } } } } } else { while (++i < n) { // Find the first comparable value. if ((value = valueof(values[i], i, values)) != null && value >= value) { max = value; while (++i < n) { // Compare the remaining values. if ((value = valueof(values[i], i, values)) != null && value > max) { max = value; } } } } } return max; } function mean(values, valueof) { var n = values.length, m = n, i = -1, value, sum = 0; if (valueof == null) { while (++i < n) { if (!isNaN(value = number(values[i]))) sum += value; else --m; } } else { while (++i < n) { if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value; else --m; } } if (m) return sum / m; } function median(values, valueof) { var n = values.length, i = -1, value, numbers = []; if (valueof == null) { while (++i < n) { if (!isNaN(value = number(values[i]))) { numbers.push(value); } } } else { while (++i < n) { if (!isNaN(value = number(valueof(values[i], i, values)))) { numbers.push(value); } } } return threshold(numbers.sort(ascending), 0.5); } function merge(arrays) { var n = arrays.length, m, i = -1, j = 0, merged, array; while (++i < n) j += arrays[i].length; merged = new Array(j); while (--n >= 0) { array = arrays[n]; m = array.length; while (--m >= 0) { merged[--j] = array[m]; } } return merged; } function min(values, valueof) { var n = values.length, i = -1, value, min; if (valueof == null) { while (++i < n) { // Find the first comparable value. if ((value = values[i]) != null && value >= value) { min = value; while (++i < n) { // Compare the remaining values. if ((value = values[i]) != null && min > value) { min = value; } } } } } else { while (++i < n) { // Find the first comparable value. if ((value = valueof(values[i], i, values)) != null && value >= value) { min = value; while (++i < n) { // Compare the remaining values. if ((value = valueof(values[i], i, values)) != null && min > value) { min = value; } } } } } return min; } function permute(array, indexes) { var i = indexes.length, permutes = new Array(i); while (i--) permutes[i] = array[indexes[i]]; return permutes; } function scan(values, compare) { if (!(n = values.length)) return; var n, i = 0, j = 0, xi, xj = values[j]; if (compare == null) compare = ascending; while (++i < n) { if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) { xj = xi, j = i; } } if (compare(xj, xj) === 0) return j; } function shuffle(array, i0, i1) { var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i; while (m) { i = Math.random() * m-- | 0; t = array[m + i0]; array[m + i0] = array[i + i0]; array[i + i0] = t; } return array; } function sum(values, valueof) { var n = values.length, i = -1, value, sum = 0; if (valueof == null) { while (++i < n) { if (value = +values[i]) sum += value; // Note: zero and null are equivalent. } } else { while (++i < n) { if (value = +valueof(values[i], i, values)) sum += value; } } return sum; } function transpose(matrix) { if (!(n = matrix.length)) return []; for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) { for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) { row[j] = matrix[j][i]; } } return transpose; } function length(d) { return d.length; } function zip() { return transpose(arguments); } var slice$1 = Array.prototype.slice; function identity$1(x) { return x; } var top = 1; var right = 2; var bottom = 3; var left = 4; var epsilon = 1e-6; function translateX(x) { return \"translate(\" + (x + 0.5) + \",0)\"; } function translateY(y) { return \"translate(0,\" + (y + 0.5) + \")\"; } function number$1(scale) { return function(d) { return +scale(d); }; } function center(scale) { var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset. if (scale.round()) offset = Math.round(offset); return function(d) { return +scale(d) + offset; }; } function entering() { return !this.__axis; } function axis(orient, scale) { var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? \"x\" : \"y\", transform = orient === top || orient === bottom ? translateX : translateY; function axis(context) { var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues, format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center : number$1)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(\".domain\").data([null]), tick = selection.selectAll(\".tick\").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append(\"g\").attr(\"class\", \"tick\"), line = tick.select(\"line\"), text = tick.select(\"text\"); path = path.merge(path.enter().insert(\"path\", \".tick\") .attr(\"class\", \"domain\") .attr(\"stroke\", \"#000\")); tick = tick.merge(tickEnter); line = line.merge(tickEnter.append(\"line\") .attr(\"stroke\", \"#000\") .attr(x + \"2\", k * tickSizeInner)); text = text.merge(tickEnter.append(\"text\") .attr(\"fill\", \"#000\") .attr(x, k * spacing) .attr(\"dy\", orient === top ? \"0em\" : orient === bottom ? \"0.71em\" : \"0.32em\")); if (context !== selection) { path = path.transition(context); tick = tick.transition(context); line = line.transition(context); text = text.transition(context); tickExit = tickExit.transition(context) .attr(\"opacity\", epsilon) .attr(\"transform\", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute(\"transform\"); }); tickEnter .attr(\"opacity\", epsilon) .attr(\"transform\", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); }); } tickExit.remove(); path .attr(\"d\", orient === left || orient == right ? \"M\" + k * tickSizeOuter + \",\" + range0 + \"H0.5V\" + range1 + \"H\" + k * tickSizeOuter : \"M\" + range0 + \",\" + k * tickSizeOuter + \"V0.5H\" + range1 + \"V\" + k * tickSizeOuter); tick .attr(\"opacity\", 1) .attr(\"transform\", function(d) { return transform(position(d)); }); line .attr(x + \"2\", k * tickSizeInner); text .attr(x, k * spacing) .text(format); selection.filter(entering) .attr(\"fill\", \"none\") .attr(\"font-size\", 10) .attr(\"font-family\", \"sans-serif\") .attr(\"text-anchor\", orient === right ? \"start\" : orient === left ? \"end\" : \"middle\"); selection .each(function() { this.__axis = position; }); } axis.scale = function(_) { return arguments.length ? (scale = _, axis) : scale; }; axis.ticks = function() { return tickArguments = slice$1.call(arguments), axis; }; axis.tickArguments = function(_) { return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice(); }; axis.tickValues = function(_) { return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice(); }; axis.tickFormat = function(_) { return arguments.length ? (tickFormat = _, axis) : tickFormat; }; axis.tickSize = function(_) { return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner; }; axis.tickSizeInner = function(_) { return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner; }; axis.tickSizeOuter = function(_) { return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter; }; axis.tickPadding = function(_) { return arguments.length ? (tickPadding = +_, axis) : tickPadding; }; return axis; } function axisTop(scale) { return axis(top, scale); } function axisRight(scale) { return axis(right, scale); } function axisBottom(scale) { return axis(bottom, scale); } function axisLeft(scale) { return axis(left, scale); } var noop = {value: function() {}}; function dispatch() { for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) { if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t); _[t] = []; } return new Dispatch(_); } function Dispatch(_) { this._ = _; } function parseTypenames(typenames, types) { return typenames.trim().split(/^|\\s+/).map(function(t) { var name = \"\", i = t.indexOf(\".\"); if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i); if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t); return {type: t, name: name}; }); } Dispatch.prototype = dispatch.prototype = { constructor: Dispatch, on: function(typename, callback) { var _ = this._, T = parseTypenames(typename + \"\", _), t, i = -1, n = T.length; // If no callback was specified, return the callback of the given type and name. if (arguments.length < 2) { while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t; return; } // If a type was specified, set the callback for the given type and name. // Otherwise, if a null callback was specified, remove callbacks of the given name. if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback); while (++i < n) { if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback); else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null); } return this; }, copy: function() { var copy = {}, _ = this._; for (var t in _) copy[t] = _[t].slice(); return new Dispatch(copy); }, call: function(type, that) { if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2]; if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type); for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args); }, apply: function(type, that, args) { if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type); for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args); } }; function get(type, name) { for (var i = 0, n = type.length, c; i < n; ++i) { if ((c = type[i]).name === name) { return c.value; } } } function set(type, name, callback) { for (var i = 0, n = type.length; i < n; ++i) { if (type[i].name === name) { type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1)); break; } } if (callback != null) type.push({name: name, value: callback}); return type; } var xhtml = \"http://www.w3.org/1999/xhtml\"; var namespaces = { svg: \"http://www.w3.org/2000/svg\", xhtml: xhtml, xlink: \"http://www.w3.org/1999/xlink\", xml: \"http://www.w3.org/XML/1998/namespace\", xmlns: \"http://www.w3.org/2000/xmlns/\" }; function namespace(name) { var prefix = name += \"\", i = prefix.indexOf(\":\"); if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1); return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; } function creatorInherit(name) { return function() { var document = this.ownerDocument, uri = this.namespaceURI; return uri === xhtml && document.documentElement.namespaceURI === xhtml ? document.createElement(name) : document.createElementNS(uri, name); }; } function creatorFixed(fullname) { return function() { return this.ownerDocument.createElementNS(fullname.space, fullname.local); }; } function creator(name) { var fullname = namespace(name); return (fullname.local ? creatorFixed : creatorInherit)(fullname); } function none() {} function selector(selector) { return selector == null ? none : function() { return this.querySelector(selector); }; } function selection_select(select) { if (typeof select !== \"function\") select = selector(select); for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) { if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) { if (\"__data__\" in node) subnode.__data__ = node.__data__; subgroup[i] = subnode; } } } return new Selection(subgroups, this._parents); } function empty$1() { return []; } function selectorAll(selector) { return selector == null ? empty$1 : function() { return this.querySelectorAll(selector); }; } function selection_selectAll(select) { if (typeof select !== \"function\") select = selectorAll(select); for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) { if (node = group[i]) { subgroups.push(select.call(node, node.__data__, i, group)); parents.push(node); } } } return new Selection(subgroups, parents); } var matcher = function(selector) { return function() { return this.matches(selector); }; }; if (typeof document !== \"undefined\") { var element = document.documentElement; if (!element.matches) { var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector; matcher = function(selector) { return function() { return vendorMatches.call(this, selector); }; }; } } var matcher$1 = matcher; function selection_filter(match) { if (typeof match !== \"function\") match = matcher$1(match); for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) { if ((node = group[i]) && match.call(node, node.__data__, i, group)) { subgroup.push(node); } } } return new Selection(subgroups, this._parents); } function sparse(update) { return new Array(update.length); } function selection_enter() { return new Selection(this._enter || this._groups.map(sparse), this._parents); } function EnterNode(parent, datum) { this.ownerDocument = parent.ownerDocument; this.namespaceURI = parent.namespaceURI; this._next = null; this._parent = parent; this.__data__ = datum; } EnterNode.prototype = { constructor: EnterNode, appendChild: function(child) { return this._parent.insertBefore(child, this._next); }, insertBefore: function(child, next) { return this._parent.insertBefore(child, next); }, querySelector: function(selector) { return this._parent.querySelector(selector); }, querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); } }; function constant$1(x) { return function() { return x; }; } var keyPrefix = \"$\"; // Protect against keys like “__proto__”. function bindIndex(parent, group, enter, update, exit, data) { var i = 0, node, groupLength = group.length, dataLength = data.length; // Put any non-null nodes that fit into update. // Put any null nodes into enter. // Put any remaining data into enter. for (; i < dataLength; ++i) { if (node = group[i]) { node.__data__ = data[i]; update[i] = node; } else { enter[i] = new EnterNode(parent, data[i]); } } // Put any non-null nodes that don’t fit into exit. for (; i < groupLength; ++i) { if (node = group[i]) { exit[i] = node; } } } function bindKey(parent, group, enter, update, exit, data, key) { var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue; // Compute the key for each node. // If multiple nodes have the same key, the duplicates are added to exit. for (i = 0; i < groupLength; ++i) { if (node = group[i]) { keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group); if (keyValue in nodeByKeyValue) { exit[i] = node; } else { nodeByKeyValue[keyValue] = node; } } } // Compute the key for each datum. // If there a node associated with this key, join and add it to update. // If there is not (or the key is a duplicate), add it to enter. for (i = 0; i < dataLength; ++i) { keyValue = keyPrefix + key.call(parent, data[i], i, data); if (node = nodeByKeyValue[keyValue]) { update[i] = node; node.__data__ = data[i]; nodeByKeyValue[keyValue] = null; } else { enter[i] = new EnterNode(parent, data[i]); } } // Add any remaining nodes that were not bound to data to exit. for (i = 0; i < groupLength; ++i) { if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) { exit[i] = node; } } } function selection_data(value, key) { if (!value) { data = new Array(this.size()), j = -1; this.each(function(d) { data[++j] = d; }); return data; } var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups; if (typeof value !== \"function\") value = constant$1(value); for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) { var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength); bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that // appendChild can insert the materialized enter node before this node, // rather than at the end of the parent node. for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) { if (previous = enterGroup[i0]) { if (i0 >= i1) i1 = i0 + 1; while (!(next = updateGroup[i1]) && ++i1 < dataLength); previous._next = next || null; } } } update = new Selection(update, parents); update._enter = enter; update._exit = exit; return update; } function selection_exit() { return new Selection(this._exit || this._groups.map(sparse), this._parents); } function selection_merge(selection$$1) { for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) { for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) { if (node = group0[i] || group1[i]) { merge[i] = node; } } } for (; j < m0; ++j) { merges[j] = groups0[j]; } return new Selection(merges, this._parents); } function selection_order() { for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) { for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) { if (node = group[i]) { if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next); next = node; } } } return this; } function selection_sort(compare) { if (!compare) compare = ascending$1; function compareNode(a, b) { return a && b ? compare(a.__data__, b.__data__) : !a - !b; } for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) { if (node = group[i]) { sortgroup[i] = node; } } sortgroup.sort(compareNode); } return new Selection(sortgroups, this._parents).order(); } function ascending$1(a, b) { return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; } function selection_call() { var callback = arguments[0]; arguments[0] = this; callback.apply(null, arguments); return this; } function selection_nodes() { var nodes = new Array(this.size()), i = -1; this.each(function() { nodes[++i] = this; }); return nodes; } function selection_node() { for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) { for (var group = groups[j], i = 0, n = group.length; i < n; ++i) { var node = group[i]; if (node) return node; } } return null; } function selection_size() { var size = 0; this.each(function() { ++size; }); return size; } function selection_empty() { return !this.node(); } function selection_each(callback) { for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) { for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) { if (node = group[i]) callback.call(node, node.__data__, i, group); } } return this; } function attrRemove(name) { return function() { this.removeAttribute(name); }; } function attrRemoveNS(fullname) { return function() { this.removeAttributeNS(fullname.space, fullname.local); }; } function attrConstant(name, value) { return function() { this.setAttribute(name, value); }; } function attrConstantNS(fullname, value) { return function() { this.setAttributeNS(fullname.space, fullname.local, value); }; } function attrFunction(name, value) { return function() { var v = value.apply(this, arguments); if (v == null) this.removeAttribute(name); else this.setAttribute(name, v); }; } function attrFunctionNS(fullname, value) { return function() { var v = value.apply(this, arguments); if (v == null) this.removeAttributeNS(fullname.space, fullname.local); else this.setAttributeNS(fullname.space, fullname.local, v); }; } function selection_attr(name, value) { var fullname = namespace(name); if (arguments.length < 2) { var node = this.node(); return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname); } return this.each((value == null ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === \"function\" ? (fullname.local ? attrFunctionNS : attrFunction) : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value)); } function defaultView(node) { return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node || (node.document && node) // node is a Window || node.defaultView; // node is a Document } function styleRemove(name) { return function() { this.style.removeProperty(name); }; } function styleConstant(name, value, priority) { return function() { this.style.setProperty(name, value, priority); }; } function styleFunction(name, value, priority) { return function() { var v = value.apply(this, arguments); if (v == null) this.style.removeProperty(name); else this.style.setProperty(name, v, priority); }; } function selection_style(name, value, priority) { return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === \"function\" ? styleFunction : styleConstant)(name, value, priority == null ? \"\" : priority)) : styleValue(this.node(), name); } function styleValue(node, name) { return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name); } function propertyRemove(name) { return function() { delete this[name]; }; } function propertyConstant(name, value) { return function() { this[name] = value; }; } function propertyFunction(name, value) { return function() { var v = value.apply(this, arguments); if (v == null) delete this[name]; else this[name] = v; }; } function selection_property(name, value) { return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === \"function\" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name]; } function classArray(string) { return string.trim().split(/^|\\s+/); } function classList(node) { return node.classList || new ClassList(node); } function ClassList(node) { this._node = node; this._names = classArray(node.getAttribute(\"class\") || \"\"); } ClassList.prototype = { add: function(name) { var i = this._names.indexOf(name); if (i < 0) { this._names.push(name); this._node.setAttribute(\"class\", this._names.join(\" \")); } }, remove: function(name) { var i = this._names.indexOf(name); if (i >= 0) { this._names.splice(i, 1); this._node.setAttribute(\"class\", this._names.join(\" \")); } }, contains: function(name) { return this._names.indexOf(name) >= 0; } }; function classedAdd(node, names) { var list = classList(node), i = -1, n = names.length; while (++i < n) list.add(names[i]); } function classedRemove(node, names) { var list = classList(node), i = -1, n = names.length; while (++i < n) list.remove(names[i]); } function classedTrue(names) { return function() { classedAdd(this, names); }; } function classedFalse(names) { return function() { classedRemove(this, names); }; } function classedFunction(names, value) { return function() { (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names); }; } function selection_classed(name, value) { var names = classArray(name + \"\"); if (arguments.length < 2) { var list = classList(this.node()), i = -1, n = names.length; while (++i < n) if (!list.contains(names[i])) return false; return true; } return this.each((typeof value === \"function\" ? classedFunction : value ? classedTrue : classedFalse)(names, value)); } function textRemove() { this.textContent = \"\"; } function textConstant(value) { return function() { this.textContent = value; }; } function textFunction(value) { return function() { var v = value.apply(this, arguments); this.textContent = v == null ? \"\" : v; }; } function selection_text(value) { return arguments.length ? this.each(value == null ? textRemove : (typeof value === \"function\" ? textFunction : textConstant)(value)) : this.node().textContent; } function htmlRemove() { this.innerHTML = \"\"; } function htmlConstant(value) { return function() { this.innerHTML = value; }; } function htmlFunction(value) { return function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? \"\" : v; }; } function selection_html(value) { return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === \"function\" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML; } function raise() { if (this.nextSibling) this.parentNode.appendChild(this); } function selection_raise() { return this.each(raise); } function lower() { if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild); } function selection_lower() { return this.each(lower); } function selection_append(name) { var create = typeof name === \"function\" ? name : creator(name); return this.select(function() { return this.appendChild(create.apply(this, arguments)); }); } function constantNull() { return null; } function selection_insert(name, before) { var create = typeof name === \"function\" ? name : creator(name), select = before == null ? constantNull : typeof before === \"function\" ? before : selector(before); return this.select(function() { return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null); }); } function remove() { var parent = this.parentNode; if (parent) parent.removeChild(this); } function selection_remove() { return this.each(remove); } function selection_cloneShallow() { return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling); } function selection_cloneDeep() { return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling); } function selection_clone(deep) { return this.select(deep ? selection_cloneDeep : selection_cloneShallow); } function selection_datum(value) { return arguments.length ? this.property(\"__data__\", value) : this.node().__data__; } var filterEvents = {}; exports.event = null; if (typeof document !== \"undefined\") { var element$1 = document.documentElement; if (!(\"onmouseenter\" in element$1)) { filterEvents = {mouseenter: \"mouseover\", mouseleave: \"mouseout\"}; } } function filterContextListener(listener, index, group) { listener = contextListener(listener, index, group); return function(event) { var related = event.relatedTarget; if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) { listener.call(this, event); } }; } function contextListener(listener, index, group) { return function(event1) { var event0 = exports.event; // Events can be reentrant (e.g., focus). exports.event = event1; try { listener.call(this, this.__data__, index, group); } finally { exports.event = event0; } }; } function parseTypenames$1(typenames) { return typenames.trim().split(/^|\\s+/).map(function(t) { var name = \"\", i = t.indexOf(\".\"); if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i); return {type: t, name: name}; }); } function onRemove(typename) { return function() { var on = this.__on; if (!on) return; for (var j = 0, i = -1, m = on.length, o; j < m; ++j) { if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) { this.removeEventListener(o.type, o.listener, o.capture); } else { on[++i] = o; } } if (++i) on.length = i; else delete this.__on; }; } function onAdd(typename, value, capture) { var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener; return function(d, i, group) { var on = this.__on, o, listener = wrap(value, i, group); if (on) for (var j = 0, m = on.length; j < m; ++j) { if ((o = on[j]).type === typename.type && o.name === typename.name) { this.removeEventListener(o.type, o.listener, o.capture); this.addEventListener(o.type, o.listener = listener, o.capture = capture); o.value = value; return; } } this.addEventListener(typename.type, listener, capture); o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture}; if (!on) this.__on = [o]; else on.push(o); }; } function selection_on(typename, value, capture) { var typenames = parseTypenames$1(typename + \"\"), i, n = typenames.length, t; if (arguments.length < 2) { var on = this.node().__on; if (on) for (var j = 0, m = on.length, o; j < m; ++j) { for (i = 0, o = on[j]; i < n; ++i) { if ((t = typenames[i]).type === o.type && t.name === o.name) { return o.value; } } } return; } on = value ? onAdd : onRemove; if (capture == null) capture = false; for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture)); return this; } function customEvent(event1, listener, that, args) { var event0 = exports.event; event1.sourceEvent = exports.event; exports.event = event1; try { return listener.apply(that, args); } finally { exports.event = event0; } } function dispatchEvent(node, type, params) { var window = defaultView(node), event = window.CustomEvent; if (typeof event === \"function\") { event = new event(type, params); } else { event = window.document.createEvent(\"Event\"); if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail; else event.initEvent(type, false, false); } node.dispatchEvent(event); } function dispatchConstant(type, params) { return function() { return dispatchEvent(this, type, params); }; } function dispatchFunction(type, params) { return function() { return dispatchEvent(this, type, params.apply(this, arguments)); }; } function selection_dispatch(type, params) { return this.each((typeof params === \"function\" ? dispatchFunction : dispatchConstant)(type, params)); } var root = [null]; function Selection(groups, parents) { this._groups = groups; this._parents = parents; } function selection() { return new Selection([[document.documentElement]], root); } Selection.prototype = selection.prototype = { constructor: Selection, select: selection_select, selectAll: selection_selectAll, filter: selection_filter, data: selection_data, enter: selection_enter, exit: selection_exit, merge: selection_merge, order: selection_order, sort: selection_sort, call: selection_call, nodes: selection_nodes, node: selection_node, size: selection_size, empty: selection_empty, each: selection_each, attr: selection_attr, style: selection_style, property: selection_property, classed: selection_classed, text: selection_text, html: selection_html, raise: selection_raise, lower: selection_lower, append: selection_append, insert: selection_insert, remove: selection_remove, clone: selection_clone, datum: selection_datum, on: selection_on, dispatch: selection_dispatch }; function select(selector) { return typeof selector === \"string\" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root); } function create(name) { return select(creator(name).call(document.documentElement)); } var nextId = 0; function local$1() { return new Local; } function Local() { this._ = \"@\" + (++nextId).toString(36); } Local.prototype = local$1.prototype = { constructor: Local, get: function(node) { var id = this._; while (!(id in node)) if (!(node = node.parentNode)) return; return node[id]; }, set: function(node, value) { return node[this._] = value; }, remove: function(node) { return this._ in node && delete node[this._]; }, toString: function() { return this._; } }; function sourceEvent() { var current = exports.event, source; while (source = current.sourceEvent) current = source; return current; } function point(node, event) { var svg = node.ownerSVGElement || node; if (svg.createSVGPoint) { var point = svg.createSVGPoint(); point.x = event.clientX, point.y = event.clientY; point = point.matrixTransform(node.getScreenCTM().inverse()); return [point.x, point.y]; } var rect = node.getBoundingClientRect(); return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop]; } function mouse(node) { var event = sourceEvent(); if (event.changedTouches) event = event.changedTouches[0]; return point(node, event); } function selectAll(selector) { return typeof selector === \"string\" ? new Selection([document.querySelectorAll(selector)], [document.documentElement]) : new Selection([selector == null ? [] : selector], root); } function touch(node, touches, identifier) { if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches; for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) { if ((touch = touches[i]).identifier === identifier) { return point(node, touch); } } return null; } function touches(node, touches) { if (touches == null) touches = sourceEvent().touches; for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) { points[i] = point(node, touches[i]); } return points; } function nopropagation() { exports.event.stopImmediatePropagation(); } function noevent() { exports.event.preventDefault(); exports.event.stopImmediatePropagation(); } function dragDisable(view) { var root = view.document.documentElement, selection = select(view).on(\"dragstart.drag\", noevent, true); if (\"onselectstart\" in root) { selection.on(\"selectstart.drag\", noevent, true); } else { root.__noselect = root.style.MozUserSelect; root.style.MozUserSelect = \"none\"; } } function yesdrag(view, noclick) { var root = view.document.documentElement, selection = select(view).on(\"dragstart.drag\", null); if (noclick) { selection.on(\"click.drag\", noevent, true); setTimeout(function() { selection.on(\"click.drag\", null); }, 0); } if (\"onselectstart\" in root) { selection.on(\"selectstart.drag\", null); } else { root.style.MozUserSelect = root.__noselect; delete root.__noselect; } } function constant$2(x) { return function() { return x; }; } function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) { this.target = target; this.type = type; this.subject = subject; this.identifier = id; this.active = active; this.x = x; this.y = y; this.dx = dx; this.dy = dy; this._ = dispatch; } DragEvent.prototype.on = function() { var value = this._.on.apply(this._, arguments); return value === this._ ? this : value; }; // Ignore right-click, since that should open the context menu. function defaultFilter$1() { return !exports.event.button; } function defaultContainer() { return this.parentNode; } function defaultSubject(d) { return d == null ? {x: exports.event.x, y: exports.event.y} : d; } function defaultTouchable() { return \"ontouchstart\" in this; } function drag() { var filter = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch(\"start\", \"drag\", \"end\"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0; function drag(selection) { selection .on(\"mousedown.drag\", mousedowned) .filter(touchable) .on(\"touchstart.drag\", touchstarted) .on(\"touchmove.drag\", touchmoved) .on(\"touchend.drag touchcancel.drag\", touchended) .style(\"touch-action\", \"none\") .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\"); } function mousedowned() { if (touchending || !filter.apply(this, arguments)) return; var gesture = beforestart(\"mouse\", container.apply(this, arguments), mouse, this, arguments); if (!gesture) return; select(exports.event.view).on(\"mousemove.drag\", mousemoved, true).on(\"mouseup.drag\", mouseupped, true); dragDisable(exports.event.view); nopropagation(); mousemoving = false; mousedownx = exports.event.clientX; mousedowny = exports.event.clientY; gesture(\"start\"); } function mousemoved() { noevent(); if (!mousemoving) { var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny; mousemoving = dx * dx + dy * dy > clickDistance2; } gestures.mouse(\"drag\"); } function mouseupped() { select(exports.event.view).on(\"mousemove.drag mouseup.drag\", null); yesdrag(exports.event.view, mousemoving); noevent(); gestures.mouse(\"end\"); } function touchstarted() { if (!filter.apply(this, arguments)) return; var touches = exports.event.changedTouches, c = container.apply(this, arguments), n = touches.length, i, gesture; for (i = 0; i < n; ++i) { if (gesture = beforestart(touches[i].identifier, c, touch, this, arguments)) { nopropagation(); gesture(\"start\"); } } } function touchmoved() { var touches = exports.event.changedTouches, n = touches.length, i, gesture; for (i = 0; i < n; ++i) { if (gesture = gestures[touches[i].identifier]) { noevent(); gesture(\"drag\"); } } } function touchended() { var touches = exports.event.changedTouches, n = touches.length, i, gesture; if (touchending) clearTimeout(touchending); touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed! for (i = 0; i < n; ++i) { if (gesture = gestures[touches[i].identifier]) { nopropagation(); gesture(\"end\"); } } } function beforestart(id, container, point, that, args) { var p = point(container, id), s, dx, dy, sublisteners = listeners.copy(); if (!customEvent(new DragEvent(drag, \"beforestart\", s, id, active, p[0], p[1], 0, 0, sublisteners), function() { if ((exports.event.subject = s = subject.apply(that, args)) == null) return false; dx = s.x - p[0] || 0; dy = s.y - p[1] || 0; return true; })) return; return function gesture(type) { var p0 = p, n; switch (type) { case \"start\": gestures[id] = gesture, n = active++; break; case \"end\": delete gestures[id], --active; // nobreak case \"drag\": p = point(container, id), n = active; break; } customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]); }; } drag.filter = function(_) { return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$2(!!_), drag) : filter; }; drag.container = function(_) { return arguments.length ? (container = typeof _ === \"function\" ? _ : constant$2(_), drag) : container; }; drag.subject = function(_) { return arguments.length ? (subject = typeof _ === \"function\" ? _ : constant$2(_), drag) : subject; }; drag.touchable = function(_) { return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant$2(!!_), drag) : touchable; }; drag.on = function() { var value = listeners.on.apply(listeners, arguments); return value === listeners ? drag : value; }; drag.clickDistance = function(_) { return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2); }; return drag; } function define(constructor, factory, prototype) { constructor.prototype = factory.prototype = prototype; prototype.constructor = constructor; } function extend(parent, definition) { var prototype = Object.create(parent.prototype); for (var key in definition) prototype[key] = definition[key]; return prototype; } function Color() {} var darker = 0.7; var brighter = 1 / darker; var reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\"; var reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\"; var reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\"; var reHex3 = /^#([0-9a-f]{3})$/; var reHex6 = /^#([0-9a-f]{6})$/; var reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\"); var reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\"); var reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\"); var reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\"); var reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\"); var reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\"); var named = { aliceblue: 0xf0f8ff, antiquewhite: 0xfaebd7, aqua: 0x00ffff, aquamarine: 0x7fffd4, azure: 0xf0ffff, beige: 0xf5f5dc, bisque: 0xffe4c4, black: 0x000000, blanchedalmond: 0xffebcd, blue: 0x0000ff, blueviolet: 0x8a2be2, brown: 0xa52a2a, burlywood: 0xdeb887, cadetblue: 0x5f9ea0, chartreuse: 0x7fff00, chocolate: 0xd2691e, coral: 0xff7f50, cornflowerblue: 0x6495ed, cornsilk: 0xfff8dc, crimson: 0xdc143c, cyan: 0x00ffff, darkblue: 0x00008b, darkcyan: 0x008b8b, darkgoldenrod: 0xb8860b, darkgray: 0xa9a9a9, darkgreen: 0x006400, darkgrey: 0xa9a9a9, darkkhaki: 0xbdb76b, darkmagenta: 0x8b008b, darkolivegreen: 0x556b2f, darkorange: 0xff8c00, darkorchid: 0x9932cc, darkred: 0x8b0000, darksalmon: 0xe9967a, darkseagreen: 0x8fbc8f, darkslateblue: 0x483d8b, darkslategray: 0x2f4f4f, darkslategrey: 0x2f4f4f, darkturquoise: 0x00ced1, darkviolet: 0x9400d3, deeppink: 0xff1493, deepskyblue: 0x00bfff, dimgray: 0x696969, dimgrey: 0x696969, dodgerblue: 0x1e90ff, firebrick: 0xb22222, floralwhite: 0xfffaf0, forestgreen: 0x228b22, fuchsia: 0xff00ff, gainsboro: 0xdcdcdc, ghostwhite: 0xf8f8ff, gold: 0xffd700, goldenrod: 0xdaa520, gray: 0x808080, green: 0x008000, greenyellow: 0xadff2f, grey: 0x808080, honeydew: 0xf0fff0, hotpink: 0xff69b4, indianred: 0xcd5c5c, indigo: 0x4b0082, ivory: 0xfffff0, khaki: 0xf0e68c, lavender: 0xe6e6fa, lavenderblush: 0xfff0f5, lawngreen: 0x7cfc00, lemonchiffon: 0xfffacd, lightblue: 0xadd8e6, lightcoral: 0xf08080, lightcyan: 0xe0ffff, lightgoldenrodyellow: 0xfafad2, lightgray: 0xd3d3d3, lightgreen: 0x90ee90, lightgrey: 0xd3d3d3, lightpink: 0xffb6c1, lightsalmon: 0xffa07a, lightseagreen: 0x20b2aa, lightskyblue: 0x87cefa, lightslategray: 0x778899, lightslategrey: 0x778899, lightsteelblue: 0xb0c4de, lightyellow: 0xffffe0, lime: 0x00ff00, limegreen: 0x32cd32, linen: 0xfaf0e6, magenta: 0xff00ff, maroon: 0x800000, mediumaquamarine: 0x66cdaa, mediumblue: 0x0000cd, mediumorchid: 0xba55d3, mediumpurple: 0x9370db, mediumseagreen: 0x3cb371, mediumslateblue: 0x7b68ee, mediumspringgreen: 0x00fa9a, mediumturquoise: 0x48d1cc, mediumvioletred: 0xc71585, midnightblue: 0x191970, mintcream: 0xf5fffa, mistyrose: 0xffe4e1, moccasin: 0xffe4b5, navajowhite: 0xffdead, navy: 0x000080, oldlace: 0xfdf5e6, olive: 0x808000, olivedrab: 0x6b8e23, orange: 0xffa500, orangered: 0xff4500, orchid: 0xda70d6, palegoldenrod: 0xeee8aa, palegreen: 0x98fb98, paleturquoise: 0xafeeee, palevioletred: 0xdb7093, papayawhip: 0xffefd5, peachpuff: 0xffdab9, peru: 0xcd853f, pink: 0xffc0cb, plum: 0xdda0dd, powderblue: 0xb0e0e6, purple: 0x800080, rebeccapurple: 0x663399, red: 0xff0000, rosybrown: 0xbc8f8f, royalblue: 0x4169e1, saddlebrown: 0x8b4513, salmon: 0xfa8072, sandybrown: 0xf4a460, seagreen: 0x2e8b57, seashell: 0xfff5ee, sienna: 0xa0522d, silver: 0xc0c0c0, skyblue: 0x87ceeb, slateblue: 0x6a5acd, slategray: 0x708090, slategrey: 0x708090, snow: 0xfffafa, springgreen: 0x00ff7f, steelblue: 0x4682b4, tan: 0xd2b48c, teal: 0x008080, thistle: 0xd8bfd8, tomato: 0xff6347, turquoise: 0x40e0d0, violet: 0xee82ee, wheat: 0xf5deb3, white: 0xffffff, whitesmoke: 0xf5f5f5, yellow: 0xffff00, yellowgreen: 0x9acd32 }; define(Color, color, { displayable: function() { return this.rgb().displayable(); }, toString: function() { return this.rgb() + \"\"; } }); function color(format) { var m; format = (format + \"\").trim().toLowerCase(); return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) > 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1); } function rgba(r, g, b, a) { if (a t1 ? t * t * t : t2 * (t - t0); } function xyz2rgb(x) { return 255 * (x 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1; return basis((t - i / n) * n, v0, v1, v2, v3); }; } function basisClosed(values) { var n = values.length; return function(t) { var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n]; return basis((t - i / n) * n, v0, v1, v2, v3); }; } function constant$3(x) { return function() { return x; }; } function linear(a, d) { return function(t) { return a + t * d; }; } function exponential(a, b, y) { return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) { return Math.pow(a + t * b, y); }; } function hue(a, b) { var d = b - a; return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a); } function gamma(y) { return (y = +y) === 1 ? nogamma : function(a, b) { return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a); }; } function nogamma(a, b) { var d = b - a; return d ? linear(a, d) : constant$3(isNaN(a) ? b : a); } var interpolateRgb = (function rgbGamma(y) { var color$$1 = gamma(y); function rgb$$1(start, end) { var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r), g = color$$1(start.g, end.g), b = color$$1(start.b, end.b), opacity = nogamma(start.opacity, end.opacity); return function(t) { start.r = r(t); start.g = g(t); start.b = b(t); start.opacity = opacity(t); return start + \"\"; }; } rgb$$1.gamma = rgbGamma; return rgb$$1; })(1); function rgbSpline(spline) { return function(colors) { var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color$$1; for (i = 0; i < n; ++i) { color$$1 = rgb(colors[i]); r[i] = color$$1.r || 0; g[i] = color$$1.g || 0; b[i] = color$$1.b || 0; } r = spline(r); g = spline(g); b = spline(b); color$$1.opacity = 1; return function(t) { color$$1.r = r(t); color$$1.g = g(t); color$$1.b = b(t); return color$$1 + \"\"; }; }; } var rgbBasis = rgbSpline(basis$1); var rgbBasisClosed = rgbSpline(basisClosed); function array$1(a, b) { var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i; for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]); for (; i < nb; ++i) c[i] = b[i]; return function(t) { for (i = 0; i < na; ++i) c[i] = x[i](t); return c; }; } function date(a, b) { var d = new Date; return a = +a, b -= a, function(t) { return d.setTime(a + b * t), d; }; } function reinterpolate(a, b) { return a = +a, b -= a, function(t) { return a + b * t; }; } function object(a, b) { var i = {}, c = {}, k; if (a === null || typeof a !== \"object\") a = {}; if (b === null || typeof b !== \"object\") b = {}; for (k in b) { if (k in a) { i[k] = interpolateValue(a[k], b[k]); } else { c[k] = b[k]; } } return function(t) { for (k in i) c[k] = i[k](t); return c; }; } var reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g; var reB = new RegExp(reA.source, \"g\"); function zero(b) { return function() { return b; }; } function one(b) { return function(t) { return b(t) + \"\"; }; } function interpolateString(a, b) { var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b am, // current match in a bm, // current match in b bs, // string preceding current number in b, if any i = -1, // index in s s = [], // string constants and placeholders q = []; // number interpolators // Coerce inputs to strings. a = a + \"\", b = b + \"\"; // Interpolate pairs of numbers in a & b. while ((am = reA.exec(a)) && (bm = reB.exec(b))) { if ((bs = bm.index) > bi) { // a string precedes the next number in b bs = b.slice(bi, bs); if (s[i]) s[i] += bs; // coalesce with previous string else s[++i] = bs; } if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match if (s[i]) s[i] += bm; // coalesce with previous string else s[++i] = bm; } else { // interpolate non-matching numbers s[++i] = null; q.push({i: i, x: reinterpolate(am, bm)}); } bi = reB.lastIndex; } // Add remains of b. if (bi < b.length) { bs = b.slice(bi); if (s[i]) s[i] += bs; // coalesce with previous string else s[++i] = bs; } // Special optimization for only a single match. // Otherwise, interpolate each of the numbers and rejoin the string. return s.length < 2 ? (q[0] ? one(q[0].x) : zero(b)) : (b = q.length, function(t) { for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t); return s.join(\"\"); }); } function interpolateValue(a, b) { var t = typeof b, c; return b == null || t === \"boolean\" ? constant$3(b) : (t === \"number\" ? reinterpolate : t === \"string\" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString) : b instanceof color ? interpolateRgb : b instanceof Date ? date : Array.isArray(b) ? array$1 : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object : reinterpolate)(a, b); } function interpolateRound(a, b) { return a = +a, b -= a, function(t) { return Math.round(a + b * t); }; } var degrees = 180 / Math.PI; var identity$2 = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }; function decompose(a, b, c, d, e, f) { var scaleX, scaleY, skewX; if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX; if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX; if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY; if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX; return { translateX: e, translateY: f, rotate: Math.atan2(b, a) * degrees, skewX: Math.atan(skewX) * degrees, scaleX: scaleX, scaleY: scaleY }; } var cssNode; var cssRoot; var cssView; var svgNode; function parseCss(value) { if (value === \"none\") return identity$2; if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView; cssNode.style.transform = value; value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\"); cssRoot.removeChild(cssNode); value = value.slice(7, -1).split(\",\"); return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]); } function parseSvg(value) { if (value == null) return identity$2; if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"); svgNode.setAttribute(\"transform\", value); if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2; value = value.matrix; return decompose(value.a, value.b, value.c, value.d, value.e, value.f); } function interpolateTransform(parse, pxComma, pxParen, degParen) { function pop(s) { return s.length ? s.pop() + \" \" : \"\"; } function translate(xa, ya, xb, yb, s, q) { if (xa !== xb || ya !== yb) { var i = s.push(\"translate(\", null, pxComma, null, pxParen); q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)}); } else if (xb || yb) { s.push(\"translate(\" + xb + pxComma + yb + pxParen); } } function rotate(a, b, s, q) { if (a !== b) { if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: reinterpolate(a, b)}); } else if (b) { s.push(pop(s) + \"rotate(\" + b + degParen); } } function skewX(a, b, s, q) { if (a !== b) { q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: reinterpolate(a, b)}); } else if (b) { s.push(pop(s) + \"skewX(\" + b + degParen); } } function scale(xa, ya, xb, yb, s, q) { if (xa !== xb || ya !== yb) { var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\"); q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)}); } else if (xb !== 1 || yb !== 1) { s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\"); } } return function(a, b) { var s = [], // string constants and placeholders q = []; // number interpolators a = parse(a), b = parse(b); translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q); rotate(a.rotate, b.rotate, s, q); skewX(a.skewX, b.skewX, s, q); scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q); a = b = null; // gc return function(t) { var i = -1, n = q.length, o; while (++i < n) s[(o = q[i]).i] = o.x(t); return s.join(\"\"); }; }; } var interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\"); var interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\"); var rho = Math.SQRT2; var rho2 = 2; var rho4 = 4; var epsilon2 = 1e-12; function cosh(x) { return ((x = Math.exp(x)) + 1 / x) / 2; } function sinh(x) { return ((x = Math.exp(x)) - 1 / x) / 2; } function tanh(x) { return ((x = Math.exp(2 * x)) - 1) / (x + 1); } // p0 = [ux0, uy0, w0] // p1 = [ux1, uy1, w1] function interpolateZoom(p0, p1) { var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S; // Special case for u0 ? u1. if (d2 < epsilon2) { S = Math.log(w1 / w0) / rho; i = function(t) { return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S) ]; }; } // General case. else { var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1); S = (r1 - r0) / rho; i = function(t) { var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0)); return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0) ]; }; } i.duration = S * 1000; return i; } function hsl$1(hue$$1) { return function(start, end) { var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity); return function(t) { start.h = h(t); start.s = s(t); start.l = l(t); start.opacity = opacity(t); return start + \"\"; }; } } var hsl$2 = hsl$1(hue); var hslLong = hsl$1(nogamma); function lab$1(start, end) { var l = nogamma((start = lab(start)).l, (end = lab(end)).l), a = nogamma(start.a, end.a), b = nogamma(start.b, end.b), opacity = nogamma(start.opacity, end.opacity); return function(t) { start.l = l(t); start.a = a(t); start.b = b(t); start.opacity = opacity(t); return start + \"\"; }; } function hcl$1(hue$$1) { return function(start, end) { var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity); return function(t) { start.h = h(t); start.c = c(t); start.l = l(t); start.opacity = opacity(t); return start + \"\"; }; } } var hcl$2 = hcl$1(hue); var hclLong = hcl$1(nogamma); function cubehelix$1(hue$$1) { return (function cubehelixGamma(y) { y = +y; function cubehelix$$1(start, end) { var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity); return function(t) { start.h = h(t); start.s = s(t); start.l = l(Math.pow(t, y)); start.opacity = opacity(t); return start + \"\"; }; } cubehelix$$1.gamma = cubehelixGamma; return cubehelix$$1; })(1); } var cubehelix$2 = cubehelix$1(hue); var cubehelixLong = cubehelix$1(nogamma); function quantize(interpolator, n) { var samples = new Array(n); for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1)); return samples; } var frame = 0; var timeout = 0; var interval = 0; var pokeDelay = 1000; var taskHead; var taskTail; var clockLast = 0; var clockNow = 0; var clockSkew = 0; var clock = typeof performance === \"object\" && performance.now ? performance : Date; var setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); }; function now() { return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew); } function clearNow() { clockNow = 0; } function Timer() { this._call = this._time = this._next = null; } Timer.prototype = timer.prototype = { constructor: Timer, restart: function(callback, delay, time) { if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\"); time = (time == null ? now() : +time) + (delay == null ? 0 : +delay); if (!this._next && taskTail !== this) { if (taskTail) taskTail._next = this; else taskHead = this; taskTail = this; } this._call = callback; this._time = time; sleep(); }, stop: function() { if (this._call) { this._call = null; this._time = Infinity; sleep(); } } }; function timer(callback, delay, time) { var t = new Timer; t.restart(callback, delay, time); return t; } function timerFlush() { now(); // Get the current time, if not already set. ++frame; // Pretend we’ve set an alarm, if we haven’t already. var t = taskHead, e; while (t) { if ((e = clockNow - t._time) >= 0) t._call.call(null, e); t = t._next; } --frame; } function wake() { clockNow = (clockLast = clock.now()) + clockSkew; frame = timeout = 0; try { timerFlush(); } finally { frame = 0; nap(); clockNow = 0; } } function poke() { var now = clock.now(), delay = now - clockLast; if (delay > pokeDelay) clockSkew -= delay, clockLast = now; } function nap() { var t0, t1 = taskHead, t2, time = Infinity; while (t1) { if (t1._call) { if (time > t1._time) time = t1._time; t0 = t1, t1 = t1._next; } else { t2 = t1._next, t1._next = null; t1 = t0 ? t0._next = t2 : taskHead = t2; } } taskTail = t0; sleep(time); } function sleep(time) { if (frame) return; // Soonest alarm already set, or will be. if (timeout) timeout = clearTimeout(timeout); var delay = time - clockNow; // Strictly less than if we recomputed clockNow. if (delay > 24) { if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew); if (interval) interval = clearInterval(interval); } else { if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay); frame = 1, setFrame(wake); } } function timeout$1(callback, delay, time) { var t = new Timer; delay = delay == null ? 0 : +delay; t.restart(function(elapsed) { t.stop(); callback(elapsed + delay); }, delay, time); return t; } function interval$1(callback, delay, time) { var t = new Timer, total = delay; if (delay == null) return t.restart(callback, delay, time), t; delay = +delay, time = time == null ? now() : +time; t.restart(function tick(elapsed) { elapsed += total; t.restart(tick, total += delay, time); callback(elapsed); }, delay, time); return t; } var emptyOn = dispatch(\"start\", \"end\", \"interrupt\"); var emptyTween = []; var CREATED = 0; var SCHEDULED = 1; var STARTING = 2; var STARTED = 3; var RUNNING = 4; var ENDING = 5; var ENDED = 6; function schedule(node, name, id, index, group, timing) { var schedules = node.__transition; if (!schedules) node.__transition = {}; else if (id in schedules) return; create$1(node, id, { name: name, index: index, // For context during callback. group: group, // For context during callback. on: emptyOn, tween: emptyTween, time: timing.time, delay: timing.delay, duration: timing.duration, ease: timing.ease, timer: null, state: CREATED }); } function init(node, id) { var schedule = get$1(node, id); if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\"); return schedule; } function set$1(node, id) { var schedule = get$1(node, id); if (schedule.state > STARTING) throw new Error(\"too late; already started\"); return schedule; } function get$1(node, id) { var schedule = node.__transition; if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\"); return schedule; } function create$1(node, id, self) { var schedules = node.__transition, tween; // Initialize the self timer when the transition is created. // Note the actual delay is not known until the first callback! schedules[id] = self; self.timer = timer(schedule, 0, self.time); function schedule(elapsed) { self.state = SCHEDULED; self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately. if (self.delay = 0) t = t.slice(0, i); return !t || t === \"start\"; }); } function onFunction(id, name, listener) { var on0, on1, sit = start(name) ? init : set$1; return function() { var schedule$$1 = sit(this, id), on = schedule$$1.on; // If this node shared a dispatch with the previous node, // just assign the updated shared dispatch and we’re done! // Otherwise, copy-on-write. if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener); schedule$$1.on = on1; }; } function transition_on(name, listener) { var id = this._id; return arguments.length < 2 ? get$1(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener)); } function removeFunction(id) { return function() { var parent = this.parentNode; for (var i in this.__transition) if (+i !== id) return; if (parent) parent.removeChild(this); }; } function transition_remove() { return this.on(\"end.remove\", removeFunction(this._id)); } function transition_select(select) { var name = this._name, id = this._id; if (typeof select !== \"function\") select = selector(select); for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) { if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) { if (\"__data__\" in node) subnode.__data__ = node.__data__; subgroup[i] = subnode; schedule(subgroup[i], name, id, i, subgroup, get$1(node, id)); } } } return new Transition(subgroups, this._parents, name, id); } function transition_selectAll(select) { var name = this._name, id = this._id; if (typeof select !== \"function\") select = selectorAll(select); for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) { if (node = group[i]) { for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) { if (child = children[k]) { schedule(child, name, id, k, children, inherit); } } subgroups.push(children); parents.push(node); } } } return new Transition(subgroups, parents, name, id); } var Selection$1 = selection.prototype.constructor; function transition_selection() { return new Selection$1(this._groups, this._parents); } function styleRemove$1(name, interpolate$$1) { var value00, value10, interpolate0; return function() { var value0 = styleValue(this, name), value1 = (this.style.removeProperty(name), styleValue(this, name)); return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1); }; } function styleRemoveEnd(name) { return function() { this.style.removeProperty(name); }; } function styleConstant$1(name, interpolate$$1, value1) { var value00, interpolate0; return function() { var value0 = styleValue(this, name); return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value1); }; } function styleFunction$1(name, interpolate$$1, value) { var value00, value10, interpolate0; return function() { var value0 = styleValue(this, name), value1 = value(this); if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name)); return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate$$1(value00 = value0, value10 = value1); }; } function transition_style(name, value, priority) { var i = (name += \"\") === \"transform\" ? interpolateTransformCss : interpolate; return value == null ? this .styleTween(name, styleRemove$1(name, i)) .on(\"end.style.\" + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === \"function\" ? styleFunction$1(name, i, tweenValue(this, \"style.\" + name, value)) : styleConstant$1(name, i, value + \"\"), priority); } function styleTween(name, value, priority) { function tween() { var node = this, i = value.apply(node, arguments); return i && function(t) { node.style.setProperty(name, i(t), priority); }; } tween._value = value; return tween; } function transition_styleTween(name, value, priority) { var key = \"style.\" + (name += \"\"); if (arguments.length < 2) return (key = this.tween(key)) && key._value; if (value == null) return this.tween(key, null); if (typeof value !== \"function\") throw new Error; return this.tween(key, styleTween(name, value, priority == null ? \"\" : priority)); } function textConstant$1(value) { return function() { this.textContent = value; }; } function textFunction$1(value) { return function() { var value1 = value(this); this.textContent = value1 == null ? \"\" : value1; }; } function transition_text(value) { return this.tween(\"text\", typeof value === \"function\" ? textFunction$1(tweenValue(this, \"text\", value)) : textConstant$1(value == null ? \"\" : value + \"\")); } function transition_transition() { var name = this._name, id0 = this._id, id1 = newId(); for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) { for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) { if (node = group[i]) { var inherit = get$1(node, id0); schedule(node, name, id1, i, group, { time: inherit.time + inherit.delay + inherit.duration, delay: 0, duration: inherit.duration, ease: inherit.ease }); } } } return new Transition(groups, this._parents, name, id1); } var id = 0; function Transition(groups, parents, name, id) { this._groups = groups; this._parents = parents; this._name = name; this._id = id; } function transition(name) { return selection().transition(name); } function newId() { return ++id; } var selection_prototype = selection.prototype; Transition.prototype = transition.prototype = { constructor: Transition, select: transition_select, selectAll: transition_selectAll, filter: transition_filter, merge: transition_merge, selection: transition_selection, transition: transition_transition, call: selection_prototype.call, nodes: selection_prototype.nodes, node: selection_prototype.node, size: selection_prototype.size, empty: selection_prototype.empty, each: selection_prototype.each, on: transition_on, attr: transition_attr, attrTween: transition_attrTween, style: transition_style, styleTween: transition_styleTween, text: transition_text, remove: transition_remove, tween: transition_tween, delay: transition_delay, duration: transition_duration, ease: transition_ease }; function linear$1(t) { return +t; } function quadIn(t) { return t * t; } function quadOut(t) { return t * (2 - t); } function quadInOut(t) { return ((t *= 2) Math.abs(point1[1] - point[1])) lockY = true; else lockX = true; } point = point1; moving = true; noevent$1(); move(); } function move() { var t; dx = point[0] - point0[0]; dy = point[1] - point0[1]; switch (mode) { case MODE_SPACE: case MODE_DRAG: { if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx; if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy; break; } case MODE_HANDLE: { if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0; else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx; if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0; else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy; break; } case MODE_CENTER: { if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX)); if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY)); break; } } if (e1 < w1) { signX *= -1; t = w0, w0 = e0, e0 = t; t = w1, w1 = e1, e1 = t; if (type in flipX) overlay.attr(\"cursor\", cursors[type = flipX[type]]); } if (s1 < n1) { signY *= -1; t = n0, n0 = s0, s0 = t; t = n1, n1 = s1, s1 = t; if (type in flipY) overlay.attr(\"cursor\", cursors[type = flipY[type]]); } if (state.selection) selection = state.selection; // May be set by brush.move! if (lockX) w1 = selection[0][0], e1 = selection[1][0]; if (lockY) n1 = selection[0][1], s1 = selection[1][1]; if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) { state.selection = [[w1, n1], [e1, s1]]; redraw.call(that); emit.brush(); } } function ended() { nopropagation$1(); if (exports.event.touches) { if (exports.event.touches.length) return; if (touchending) clearTimeout(touchending); touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed! group.on(\"touchmove.brush touchend.brush touchcancel.brush\", null); } else { yesdrag(exports.event.view, moving); view.on(\"keydown.brush keyup.brush mousemove.brush mouseup.brush\", null); } group.attr(\"pointer-events\", \"all\"); overlay.attr(\"cursor\", cursors.overlay); if (state.selection) selection = state.selection; // May be set by brush.move (on start)! if (empty(selection)) state.selection = null, redraw.call(that); emit.end(); } function keydowned() { switch (exports.event.keyCode) { case 16: { // SHIFT shifting = signX && signY; break; } case 18: { // ALT if (mode === MODE_HANDLE) { if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX; if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY; mode = MODE_CENTER; move(); } break; } case 32: { // SPACE; takes priority over ALT if (mode === MODE_HANDLE || mode === MODE_CENTER) { if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx; if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy; mode = MODE_SPACE; overlay.attr(\"cursor\", cursors.selection); move(); } break; } default: return; } noevent$1(); } function keyupped() { switch (exports.event.keyCode) { case 16: { // SHIFT if (shifting) { lockX = lockY = shifting = false; move(); } break; } case 18: { // ALT if (mode === MODE_CENTER) { if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1; if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1; mode = MODE_HANDLE; move(); } break; } case 32: { // SPACE if (mode === MODE_SPACE) { if (exports.event.altKey) { if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX; if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY; mode = MODE_CENTER; } else { if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1; if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1; mode = MODE_HANDLE; } overlay.attr(\"cursor\", cursors[type]); move(); } break; } default: return; } noevent$1(); } } function initialize() { var state = this.__brush || {selection: null}; state.extent = extent.apply(this, arguments); state.dim = dim; return state; } brush.extent = function(_) { return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent; }; brush.filter = function(_) { return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant$4(!!_), brush) : filter; }; brush.handleSize = function(_) { return arguments.length ? (handleSize = +_, brush) : handleSize; }; brush.on = function() { var value = listeners.on.apply(listeners, arguments); return value === listeners ? brush : value; }; return brush; } var cos = Math.cos; var sin = Math.sin; var pi$1 = Math.PI; var halfPi$1 = pi$1 / 2; var tau$1 = pi$1 * 2; var max$1 = Math.max; function compareValue(compare) { return function(a, b) { return compare( a.source.value + a.target.value, b.source.value + b.target.value ); }; } function chord() { var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null; function chord(matrix) { var n = matrix.length, groupSums = [], groupIndex = sequence(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k, x, x0, dx, i, j; // Compute the sum. k = 0, i = -1; while (++i < n) { x = 0, j = -1; while (++j < n) { x += matrix[i][j]; } groupSums.push(x); subgroupIndex.push(sequence(n)); k += x; } // Sort groups… if (sortGroups) groupIndex.sort(function(a, b) { return sortGroups(groupSums[a], groupSums[b]); }); // Sort subgroups… if (sortSubgroups) subgroupIndex.forEach(function(d, i) { d.sort(function(a, b) { return sortSubgroups(matrix[i][a], matrix[i][b]); }); }); // Convert the sum to scaling factor for [0, 2pi]. // TODO Allow start and end angle to be specified? // TODO Allow padding to be specified as percentage? k = max$1(0, tau$1 - padAngle * n) / k; dx = k ? padAngle : tau$1 / n; // Compute the start and end angle for each group and subgroup. // Note: Opera has a bug reordering object literal properties! x = 0, i = -1; while (++i < n) { x0 = x, j = -1; while (++j < n) { var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k; subgroups[dj * n + di] = { index: di, subindex: dj, startAngle: a0, endAngle: a1, value: v }; } groups[di] = { index: di, startAngle: x0, endAngle: x, value: groupSums[di] }; x += dx; } // Generate chords for each (non-empty) subgroup-subgroup link. i = -1; while (++i < n) { j = i - 1; while (++j < n) { var source = subgroups[j * n + i], target = subgroups[i * n + j]; if (source.value || target.value) { chords.push(source.value < target.value ? {source: target, target: source} : {source: source, target: target}); } } } return sortChords ? chords.sort(sortChords) : chords; } chord.padAngle = function(_) { return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle; }; chord.sortGroups = function(_) { return arguments.length ? (sortGroups = _, chord) : sortGroups; }; chord.sortSubgroups = function(_) { return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups; }; chord.sortChords = function(_) { return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._; }; return chord; } var slice$2 = Array.prototype.slice; function constant$5(x) { return function() { return x; }; } var pi$2 = Math.PI; var tau$2 = 2 * pi$2; var epsilon$1 = 1e-6; var tauEpsilon = tau$2 - epsilon$1; function Path() { this._x0 = this._y0 = // start of current subpath this._x1 = this._y1 = null; // end of current subpath this._ = \"\"; } function path() { return new Path; } Path.prototype = path.prototype = { constructor: Path, moveTo: function(x, y) { this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y); }, closePath: function() { if (this._x1 !== null) { this._x1 = this._x0, this._y1 = this._y0; this._ += \"Z\"; } }, lineTo: function(x, y) { this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y); }, quadraticCurveTo: function(x1, y1, x, y) { this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y); }, bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y); }, arcTo: function(x1, y1, x2, y2, r) { x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r; var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error. if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x1,y1). if (this._x1 === null) { this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1); } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing. else if (!(l01_2 > epsilon$1)) {} // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear? // Equivalently, is (x1,y1) coincident with (x2,y2)? // Or, is the radius zero? Line to (x1,y1). else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) { this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1); } // Otherwise, draw an arc! else { var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to. if (Math.abs(t01 - 1) > epsilon$1) { this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01); } this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21); } }, arc: function(x, y, r, a0, a1, ccw) { x = +x, y = +y, r = +r; var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error. if (r < 0) throw new Error(\"negative radius: \" + r); // Is this path empty? Move to (x0,y0). if (this._x1 === null) { this._ += \"M\" + x0 + \",\" + y0; } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0). else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) { this._ += \"L\" + x0 + \",\" + y0; } // Is this arc empty? We’re done. if (!r) return; // Does the angle go the wrong way? Flip the direction. if (da < 0) da = da % tau$2 + tau$2; // Is this a complete circle? Draw two arcs to complete the circle. if (da > tauEpsilon) { this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0); } // Is this arc non-empty? Draw an arc! else if (da > epsilon$1) { this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi$2)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1)); } }, rect: function(x, y, w, h) { this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\"; }, toString: function() { return this._; } }; function defaultSource(d) { return d.source; } function defaultTarget(d) { return d.target; } function defaultRadius(d) { return d.radius; } function defaultStartAngle(d) { return d.startAngle; } function defaultEndAngle(d) { return d.endAngle; } function ribbon() { var source = defaultSource, target = defaultTarget, radius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null; function ribbon() { var buffer, argv = slice$2.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s, argv)), sa0 = startAngle.apply(this, argv) - halfPi$1, sa1 = endAngle.apply(this, argv) - halfPi$1, sx0 = sr * cos(sa0), sy0 = sr * sin(sa0), tr = +radius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi$1, ta1 = endAngle.apply(this, argv) - halfPi$1; if (!context) context = buffer = path(); context.moveTo(sx0, sy0); context.arc(0, 0, sr, sa0, sa1); if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr? context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0)); context.arc(0, 0, tr, ta0, ta1); } context.quadraticCurveTo(0, 0, sx0, sy0); context.closePath(); if (buffer) return context = null, buffer + \"\" || null; } ribbon.radius = function(_) { return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : radius; }; ribbon.startAngle = function(_) { return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : startAngle; }; ribbon.endAngle = function(_) { return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant$5(+_), ribbon) : endAngle; }; ribbon.source = function(_) { return arguments.length ? (source = _, ribbon) : source; }; ribbon.target = function(_) { return arguments.length ? (target = _, ribbon) : target; }; ribbon.context = function(_) { return arguments.length ? (context = _ == null ? null : _, ribbon) : context; }; return ribbon; } var prefix = \"$\"; function Map() {} Map.prototype = map$1.prototype = { constructor: Map, has: function(key) { return (prefix + key) in this; }, get: function(key) { return this[prefix + key]; }, set: function(key, value) { this[prefix + key] = value; return this; }, remove: function(key) { var property = prefix + key; return property in this && delete this[property]; }, clear: function() { for (var property in this) if (property[0] === prefix) delete this[property]; }, keys: function() { var keys = []; for (var property in this) if (property[0] === prefix) keys.push(property.slice(1)); return keys; }, values: function() { var values = []; for (var property in this) if (property[0] === prefix) values.push(this[property]); return values; }, entries: function() { var entries = []; for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]}); return entries; }, size: function() { var size = 0; for (var property in this) if (property[0] === prefix) ++size; return size; }, empty: function() { for (var property in this) if (property[0] === prefix) return false; return true; }, each: function(f) { for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this); } }; function map$1(object, f) { var map = new Map; // Copy constructor. if (object instanceof Map) object.each(function(value, key) { map.set(key, value); }); // Index array by numeric index or specified key function. else if (Array.isArray(object)) { var i = -1, n = object.length, o; if (f == null) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f(o = object[i], i, object), o); } // Convert object to map. else if (object) for (var key in object) map.set(key, object[key]); return map; } function nest() { var keys = [], sortKeys = [], sortValues, rollup, nest; function apply(array, depth, createResult, setResult) { if (depth >= keys.length) { if (sortValues != null) array.sort(sortValues); return rollup != null ? rollup(array) : array; } var i = -1, n = array.length, key = keys[depth++], keyValue, value, valuesByKey = map$1(), values, result = createResult(); while (++i < n) { if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) { values.push(value); } else { valuesByKey.set(keyValue, [value]); } } valuesByKey.each(function(values, key) { setResult(result, key, apply(values, depth, createResult, setResult)); }); return result; } function entries(map, depth) { if (++depth > keys.length) return map; var array, sortKey = sortKeys[depth - 1]; if (rollup != null && depth >= keys.length) array = map.entries(); else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); }); return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array; } return nest = { object: function(array) { return apply(array, 0, createObject, setObject); }, map: function(array) { return apply(array, 0, createMap, setMap); }, entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); }, key: function(d) { keys.push(d); return nest; }, sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; }, sortValues: function(order) { sortValues = order; return nest; }, rollup: function(f) { rollup = f; return nest; } }; } function createObject() { return {}; } function setObject(object, key, value) { object[key] = value; } function createMap() { return map$1(); } function setMap(map, key, value) { map.set(key, value); } function Set() {} var proto = map$1.prototype; Set.prototype = set$2.prototype = { constructor: Set, has: proto.has, add: function(value) { value += \"\"; this[prefix + value] = value; return this; }, remove: proto.remove, clear: proto.clear, values: proto.keys, size: proto.size, empty: proto.empty, each: proto.each }; function set$2(object, f) { var set = new Set; // Copy constructor. if (object instanceof Set) object.each(function(value) { set.add(value); }); // Otherwise, assume it’s an array. else if (object) { var i = -1, n = object.length; if (f == null) while (++i < n) set.add(object[i]); else while (++i < n) set.add(f(object[i], i, object)); } return set; } function keys(map) { var keys = []; for (var key in map) keys.push(key); return keys; } function values(map) { var values = []; for (var key in map) values.push(map[key]); return values; } function entries(map) { var entries = []; for (var key in map) entries.push({key: key, value: map[key]}); return entries; } var EOL = {}; var EOF = {}; var QUOTE = 34; var NEWLINE = 10; var RETURN = 13; function objectConverter(columns) { return new Function(\"d\", \"return {\" + columns.map(function(name, i) { return JSON.stringify(name) + \": d[\" + i + \"]\"; }).join(\",\") + \"}\"); } function customConverter(columns, f) { var object = objectConverter(columns); return function(row, i) { return f(object(row), i, columns); }; } // Compute unique columns in order of discovery. function inferColumns(rows) { var columnSet = Object.create(null), columns = []; rows.forEach(function(row) { for (var column in row) { if (!(column in columnSet)) { columns.push(columnSet[column] = column); } } }); return columns; } function dsv(delimiter) { var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0); function parse(text, f) { var convert, columns, rows = parseRows(text, function(row, i) { if (convert) return convert(row, i - 1); columns = row, convert = f ? customConverter(row, f) : objectConverter(row); }); rows.columns = columns || []; return rows; } function parseRows(text, f) { var rows = [], // output rows N = text.length, I = 0, // current character index n = 0, // current line number t, // current token eof = N = (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm; if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym; if (parent = node, !(node = node[i = bottom = (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm; if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym; } while ((i = bottom = ym) = xm))); return parent[j] = node, parent[i] = leaf, tree; } function addAll(data) { var d, i, n = data.length, x, y, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity; // Compute the points and their extent. for (i = 0; i < n; ++i) { if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue; xz[i] = x; yz[i] = y; if (x < x0) x0 = x; if (x > x1) x1 = x; if (y < y0) y0 = y; if (y > y1) y1 = y; } // If there were no (valid) points, inherit the existing extent. if (x1 < x0) x0 = this._x0, x1 = this._x1; if (y1 < y0) y0 = this._y0, y1 = this._y1; // Expand the tree to cover the new points. this.cover(x0, y0).cover(x1, y1); // Add the new points. for (i = 0; i < n; ++i) { add(this, xz[i], yz[i], data[i]); } return this; } function tree_cover(x, y) { if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1; // If the quadtree has no extent, initialize them. // Integer extent are necessary so that if we later double the extent, // the existing quadrant boundaries don’t change due to floating point error! if (isNaN(x0)) { x1 = (x0 = Math.floor(x)) + 1; y1 = (y0 = Math.floor(y)) + 1; } // Otherwise, double repeatedly to cover. else if (x0 > x || x > x1 || y0 > y || y > y1) { var z = x1 - x0, node = this._root, parent, i; switch (i = (y < (y0 + y1) / 2) x1 || y > y1); break; } case 1: { do parent = new Array(4), parent[i] = node, node = parent; while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1); break; } case 2: { do parent = new Array(4), parent[i] = node, node = parent; while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y); break; } case 3: { do parent = new Array(4), parent[i] = node, node = parent; while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y); break; } } if (this._root && this._root.length) this._root = node; } // If the quadtree covers the point already, just return. else return this; this._x0 = x0; this._y0 = y0; this._x1 = x1; this._y1 = y1; return this; } function tree_data() { var data = []; this.visit(function(node) { if (!node.length) do data.push(node.data); while (node = node.next) }); return data; } function tree_extent(_) { return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]]; } function Quad(node, x0, y0, x1, y1) { this.node = node; this.x0 = x0; this.y0 = y0; this.x1 = x1; this.y1 = y1; } function tree_find(x, y, radius) { var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i; if (node) quads.push(new Quad(node, x0, y0, x3, y3)); if (radius == null) radius = Infinity; else { x0 = x - radius, y0 = y - radius; x3 = x + radius, y3 = y + radius; radius *= radius; } while (q = quads.pop()) { // Stop searching if this quadrant can’t contain a closer node. if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue; // Bisect the current quadrant. if (node.length) { var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2; quads.push( new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym) ); // Visit the closest quadrant first. if (i = (y >= ym) = xm)) { q = quads[quads.length - 1]; quads[quads.length - 1] = quads[quads.length - 1 - i]; quads[quads.length - 1 - i] = q; } } // Visit this point. (Visiting coincident points isn’t necessary!) else { var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), d2 = dx * dx + dy * dy; if (d2 < radius) { var d = Math.sqrt(radius = d2); x0 = x - d, y0 = y - d; x3 = x + d, y3 = y + d; data = node.data; } } } return data; } function tree_remove(d) { if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x, y, xm, ym, right, bottom, i, j; // If the tree is empty, initialize the root as a leaf. if (!node) return this; // Find the leaf node for the point. // While descending, also retain the deepest parent with a non-removed sibling. if (node.length) while (true) { if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm; if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym; if (!(parent = node, node = node[i = bottom node.index) { var x = xi - data.x - data.vx, y = yi - data.y - data.vy, l = x * x + y * y; if (l < r * r) { if (x === 0) x = jiggle(), l += x * x; if (y === 0) y = jiggle(), l += y * y; l = (r - (l = Math.sqrt(l))) / l * strength; node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj)); node.vy += (y *= l) * r; data.vx -= x * (r = 1 - r); data.vy -= y * r; } } return; } return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r; } } function prepare(quad) { if (quad.data) return quad.r = radii[quad.data.index]; for (var i = quad.r = 0; i < 4; ++i) { if (quad[i] && quad[i].r > quad.r) { quad.r = quad[i].r; } } } function initialize() { if (!nodes) return; var i, n = nodes.length, node; radii = new Array(n); for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes); } force.initialize = function(_) { nodes = _; initialize(); }; force.iterations = function(_) { return arguments.length ? (iterations = +_, force) : iterations; }; force.strength = function(_) { return arguments.length ? (strength = +_, force) : strength; }; force.radius = function(_) { return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : radius; }; return force; } function index(d) { return d.index; } function find(nodeById, nodeId) { var node = nodeById.get(nodeId); if (!node) throw new Error(\"missing: \" + nodeId); return node; } function link(links) { var id = index, strength = defaultStrength, strengths, distance = constant$6(30), distances, nodes, count, bias, iterations = 1; if (links == null) links = []; function defaultStrength(link) { return 1 / Math.min(count[link.source.index], count[link.target.index]); } function force(alpha) { for (var k = 0, n = links.length; k < iterations; ++k) { for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) { link = links[i], source = link.source, target = link.target; x = target.x + target.vx - source.x - source.vx || jiggle(); y = target.y + target.vy - source.y - source.vy || jiggle(); l = Math.sqrt(x * x + y * y); l = (l - distances[i]) / l * alpha * strengths[i]; x *= l, y *= l; target.vx -= x * (b = bias[i]); target.vy -= y * b; source.vx += x * (b = 1 - b); source.vy += y * b; } } } function initialize() { if (!nodes) return; var i, n = nodes.length, m = links.length, nodeById = map$1(nodes, id), link; for (i = 0, count = new Array(n); i < m; ++i) { link = links[i], link.index = i; if (typeof link.source !== \"object\") link.source = find(nodeById, link.source); if (typeof link.target !== \"object\") link.target = find(nodeById, link.target); count[link.source.index] = (count[link.source.index] || 0) + 1; count[link.target.index] = (count[link.target.index] || 0) + 1; } for (i = 0, bias = new Array(m); i < m; ++i) { link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]); } strengths = new Array(m), initializeStrength(); distances = new Array(m), initializeDistance(); } function initializeStrength() { if (!nodes) return; for (var i = 0, n = links.length; i < n; ++i) { strengths[i] = +strength(links[i], i, links); } } function initializeDistance() { if (!nodes) return; for (var i = 0, n = links.length; i < n; ++i) { distances[i] = +distance(links[i], i, links); } } force.initialize = function(_) { nodes = _; initialize(); }; force.links = function(_) { return arguments.length ? (links = _, initialize(), force) : links; }; force.id = function(_) { return arguments.length ? (id = _, force) : id; }; force.iterations = function(_) { return arguments.length ? (iterations = +_, force) : iterations; }; force.strength = function(_) { return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initializeStrength(), force) : strength; }; force.distance = function(_) { return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant$6(+_), initializeDistance(), force) : distance; }; return force; } function x$1(d) { return d.x; } function y$1(d) { return d.y; } var initialRadius = 10; var initialAngle = Math.PI * (3 - Math.sqrt(5)); function simulation(nodes) { var simulation, alpha = 1, alphaMin = 0.001, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = map$1(), stepper = timer(step), event = dispatch(\"tick\", \"end\"); if (nodes == null) nodes = []; function step() { tick(); event.call(\"tick\", simulation); if (alpha < alphaMin) { stepper.stop(); event.call(\"end\", simulation); } } function tick() { var i, n = nodes.length, node; alpha += (alphaTarget - alpha) * alphaDecay; forces.each(function(force) { force(alpha); }); for (i = 0; i < n; ++i) { node = nodes[i]; if (node.fx == null) node.x += node.vx *= velocityDecay; else node.x = node.fx, node.vx = 0; if (node.fy == null) node.y += node.vy *= velocityDecay; else node.y = node.fy, node.vy = 0; } } function initializeNodes() { for (var i = 0, n = nodes.length, node; i < n; ++i) { node = nodes[i], node.index = i; if (isNaN(node.x) || isNaN(node.y)) { var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle; node.x = radius * Math.cos(angle); node.y = radius * Math.sin(angle); } if (isNaN(node.vx) || isNaN(node.vy)) { node.vx = node.vy = 0; } } } function initializeForce(force) { if (force.initialize) force.initialize(nodes); return force; } initializeNodes(); return simulation = { tick: tick, restart: function() { return stepper.restart(step), simulation; }, stop: function() { return stepper.stop(), simulation; }, nodes: function(_) { return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes; }, alpha: function(_) { return arguments.length ? (alpha = +_, simulation) : alpha; }, alphaMin: function(_) { return arguments.length ? (alphaMin = +_, simulation) : alphaMin; }, alphaDecay: function(_) { return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay; }, alphaTarget: function(_) { return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget; }, velocityDecay: function(_) { return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay; }, force: function(name, _) { return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name); }, find: function(x, y, radius) { var i = 0, n = nodes.length, dx, dy, d2, node, closest; if (radius == null) radius = Infinity; else radius *= radius; for (i = 0; i < n; ++i) { node = nodes[i]; dx = x - node.x; dy = y - node.y; d2 = dx * dx + dy * dy; if (d2 < radius) closest = node, radius = d2; } return closest; }, on: function(name, _) { return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name); } }; } function manyBody() { var nodes, node, alpha, strength = constant$6(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81; function force(_) { var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate); for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply); } function initialize() { if (!nodes) return; var i, n = nodes.length, node; strengths = new Array(n); for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes); } function accumulate(quad) { var strength = 0, q, c, weight = 0, x, y, i; // For internal nodes, accumulate forces from child quadrants. if (quad.length) { for (x = y = i = 0; i < 4; ++i) { if ((q = quad[i]) && (c = Math.abs(q.value))) { strength += q.value, weight += c, x += c * q.x, y += c * q.y; } } quad.x = x / weight; quad.y = y / weight; } // For leaf nodes, accumulate forces from coincident quadrants. else { q = quad; q.x = q.data.x; q.y = q.data.y; do strength += strengths[q.data.index]; while (q = q.next); } quad.value = strength; } function apply(quad, x1, _, x2) { if (!quad.value) return true; var x = quad.x - node.x, y = quad.y - node.y, w = x2 - x1, l = x * x + y * y; // Apply the Barnes-Hut approximation if possible. // Limit forces for very close nodes; randomize direction if coincident. if (w * w / theta2 < l) { if (l < distanceMax2) { if (x === 0) x = jiggle(), l += x * x; if (y === 0) y = jiggle(), l += y * y; if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l); node.vx += x * quad.value * alpha / l; node.vy += y * quad.value * alpha / l; } return true; } // Otherwise, process points directly. else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident. if (quad.data !== node || quad.next) { if (x === 0) x = jiggle(), l += x * x; if (y === 0) y = jiggle(), l += y * y; if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l); } do if (quad.data !== node) { w = strengths[quad.data.index] * alpha / l; node.vx += x * w; node.vy += y * w; } while (quad = quad.next); } force.initialize = function(_) { nodes = _; initialize(); }; force.strength = function(_) { return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength; }; force.distanceMin = function(_) { return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2); }; force.distanceMax = function(_) { return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2); }; force.theta = function(_) { return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2); }; return force; } function radial(radius, x, y) { var nodes, strength = constant$6(0.1), strengths, radiuses; if (typeof radius !== \"function\") radius = constant$6(+radius); if (x == null) x = 0; if (y == null) y = 0; function force(alpha) { for (var i = 0, n = nodes.length; i < n; ++i) { var node = nodes[i], dx = node.x - x || 1e-6, dy = node.y - y || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r; node.vx += dx * k; node.vy += dy * k; } } function initialize() { if (!nodes) return; var i, n = nodes.length; strengths = new Array(n); radiuses = new Array(n); for (i = 0; i < n; ++i) { radiuses[i] = +radius(nodes[i], i, nodes); strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes); } } force.initialize = function(_) { nodes = _, initialize(); }; force.strength = function(_) { return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength; }; force.radius = function(_) { return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : radius; }; force.x = function(_) { return arguments.length ? (x = +_, force) : x; }; force.y = function(_) { return arguments.length ? (y = +_, force) : y; }; return force; } function x$2(x) { var strength = constant$6(0.1), nodes, strengths, xz; if (typeof x !== \"function\") x = constant$6(x == null ? 0 : +x); function force(alpha) { for (var i = 0, n = nodes.length, node; i < n; ++i) { node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha; } } function initialize() { if (!nodes) return; var i, n = nodes.length; strengths = new Array(n); xz = new Array(n); for (i = 0; i < n; ++i) { strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes); } } force.initialize = function(_) { nodes = _; initialize(); }; force.strength = function(_) { return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength; }; force.x = function(_) { return arguments.length ? (x = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : x; }; return force; } function y$2(y) { var strength = constant$6(0.1), nodes, strengths, yz; if (typeof y !== \"function\") y = constant$6(y == null ? 0 : +y); function force(alpha) { for (var i = 0, n = nodes.length, node; i < n; ++i) { node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha; } } function initialize() { if (!nodes) return; var i, n = nodes.length; strengths = new Array(n); yz = new Array(n); for (i = 0; i < n; ++i) { strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes); } } force.initialize = function(_) { nodes = _; initialize(); }; force.strength = function(_) { return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : strength; }; force.y = function(_) { return arguments.length ? (y = typeof _ === \"function\" ? _ : constant$6(+_), initialize(), force) : y; }; return force; } // Computes the decimal coefficient and exponent of the specified number x with // significant digits p, where x is positive and p is in [1, 21] or undefined. // For example, formatDecimal(1.23) returns [\"123\", 0]. function formatDecimal(x, p) { if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, ±Infinity var i, coefficient = x.slice(0, i); // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+ // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3). return [ coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1) ]; } function exponent$1(x) { return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN; } function formatGroup(grouping, thousands) { return function(value, width) { var i = value.length, t = [], j = 0, g = grouping[0], length = 0; while (i > 0 && g > 0) { if (length + g + 1 > width) g = Math.max(1, width - length); t.push(value.substring(i -= g, i + g)); if ((length += g + 1) > width) break; g = grouping[j = (j + 1) % grouping.length]; } return t.reverse().join(thousands); }; } function formatNumerals(numerals) { return function(value) { return value.replace(/[0-9]/g, function(i) { return numerals[+i]; }); }; } function formatDefault(x, p) { x = x.toPrecision(p); out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) { switch (x[i]) { case \".\": i0 = i1 = i; break; case \"0\": if (i0 === 0) i0 = i; i1 = i; break; case \"e\": break out; default: if (i0 > 0) i0 = 0; break; } } return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x; } var prefixExponent; function formatPrefixAuto(x, p) { var d = formatDecimal(x, p); if (!d) return x + \"\"; var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length; return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join(\"0\") : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i) : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y! } function formatRounded(x, p) { var d = formatDecimal(x, p); if (!d) return x + \"\"; var coefficient = d[0], exponent = d[1]; return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\"); } var formatTypes = { \"\": formatDefault, \"%\": function(x, p) { return (x * 100).toFixed(p); }, \"b\": function(x) { return Math.round(x).toString(2); }, \"c\": function(x) { return x + \"\"; }, \"d\": function(x) { return Math.round(x).toString(10); }, \"e\": function(x, p) { return x.toExponential(p); }, \"f\": function(x, p) { return x.toFixed(p); }, \"g\": function(x, p) { return x.toPrecision(p); }, \"o\": function(x) { return Math.round(x).toString(8); }, \"p\": function(x, p) { return formatRounded(x * 100, p); }, \"r\": formatRounded, \"s\": formatPrefixAuto, \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); }, \"x\": function(x) { return Math.round(x).toString(16); } }; // [[fill]align][sign][symbol][0][width][,][.precision][type] var re = /^(?:(.)?([=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i; function formatSpecifier(specifier) { return new FormatSpecifier(specifier); } formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof function FormatSpecifier(specifier) { if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier); var match, fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zero = !!match[5], width = match[6] && +match[6], comma = !!match[7], precision = match[8] && +match[8].slice(1), type = match[9] || \"\"; // The \"n\" type is an alias for \",g\". if (type === \"n\") comma = true, type = \"g\"; // Map invalid types to the default format. else if (!formatTypes[type]) type = \"\"; // If zero fill is specified, padding goes after sign and before digits. if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\"; this.fill = fill; this.align = align; this.sign = sign; this.symbol = symbol; this.zero = zero; this.width = width; this.comma = comma; this.precision = precision; this.type = type; } FormatSpecifier.prototype.toString = function() { return this.fill + this.align + this.sign + this.symbol + (this.zero ? \"0\" : \"\") + (this.width == null ? \"\" : Math.max(1, this.width | 0)) + (this.comma ? \",\" : \"\") + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0)) + this.type; }; function identity$3(x) { return x; } var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\\xB5\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"]; function formatLocale(locale) { var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3, currency = locale.currency, decimal = locale.decimal, numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3, percent = locale.percent || \"%\"; function newFormat(specifier) { specifier = formatSpecifier(specifier); var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, type = specifier.type; // Compute the prefix and suffix. // For SI-prefix, the suffix is lazily computed. var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\", suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\"; // What format function should we use? // Is this an integer type? // Can this type generate exponential notation? var formatType = formatTypes[type], maybeSuffix = !type || /[defgprs%]/.test(type); // Set the default precision if not specified, // or clamp the specified precision to the supported range. // For significant precision, it must be in [1, 21]. // For fixed precision, it must be in [0, 20]. precision = precision == null ? (type ? 6 : 12) : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision)); function format(value) { var valuePrefix = prefix, valueSuffix = suffix, i, n, c; if (type === \"c\") { valueSuffix = formatType(value) + valueSuffix; value = \"\"; } else { value = +value; // Perform the initial formatting. var valueNegative = value < 0; value = formatType(Math.abs(value), precision); // If a negative value rounds to zero during formatting, treat as positive. if (valueNegative && +value === 0) valueNegative = false; // Compute the prefix and suffix. valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix; valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\"); // Break the formatted value into the integer “value” part that can be // grouped, and fractional or exponential “suffix” part that is not. if (maybeSuffix) { i = -1, n = value.length; while (++i < n) { if (c = value.charCodeAt(i), 48 > c || c > 57) { valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix; value = value.slice(0, i); break; } } } } // If the fill character is not \"0\", grouping is applied before padding. if (comma && !zero) value = group(value, Infinity); // Compute the padding. var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : \"\"; // If the fill character is \"0\", grouping is applied after padding. if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\"; // Reconstruct the final output based on the desired alignment. switch (align) { case \" 0) throw new Error(\"cycle\"); return root; } stratify.id = function(x) { return arguments.length ? (id = required(x), stratify) : id; }; stratify.parentId = function(x) { return arguments.length ? (parentId = required(x), stratify) : parentId; }; return stratify; } function defaultSeparation$1(a, b) { return a.parent === b.parent ? 1 : 2; } // function radialSeparation(a, b) { // return (a.parent === b.parent ? 1 : 2) / a.depth; // } // This function is used to traverse the left contour of a subtree (or // subforest). It returns the successor of v on this contour. This successor is // either given by the leftmost child of v or by the thread of v. The function // returns null if and only if v is on the highest level of its subtree. function nextLeft(v) { var children = v.children; return children ? children[0] : v.t; } // This function works analogously to nextLeft. function nextRight(v) { var children = v.children; return children ? children[children.length - 1] : v.t; } // Shifts the current subtree rooted at w+. This is done by increasing // prelim(w+) and mod(w+) by shift. function moveSubtree(wm, wp, shift) { var change = shift / (wp.i - wm.i); wp.c -= change; wp.s += shift; wm.c += change; wp.z += shift; wp.m += shift; } // All other shifts, applied to the smaller subtrees between w- and w+, are // performed by this function. To prepare the shifts, we have to adjust // change(w+), shift(w+), and change(w-). function executeShifts(v) { var shift = 0, change = 0, children = v.children, i = children.length, w; while (--i >= 0) { w = children[i]; w.z += shift; w.m += shift; shift += w.s + (change += w.c); } } // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise, // returns the specified (default) ancestor. function nextAncestor(vim, v, ancestor) { return vim.a.parent === v.parent ? vim.a : ancestor; } function TreeNode(node, i) { this._ = node; this.parent = null; this.children = null; this.A = null; // default ancestor this.a = this; // ancestor this.z = 0; // prelim this.m = 0; // mod this.c = 0; // change this.s = 0; // shift this.t = null; // thread this.i = i; // number } TreeNode.prototype = Object.create(Node.prototype); function treeRoot(root) { var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n; while (node = nodes.pop()) { if (children = node._.children) { node.children = new Array(n = children.length); for (i = n - 1; i >= 0; --i) { nodes.push(child = node.children[i] = new TreeNode(children[i], i)); child.parent = node; } } } (tree.parent = new TreeNode(null, 0)).children = [tree]; return tree; } // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm function tree() { var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null; function tree(root) { var t = treeRoot(root); // Compute the layout using Buchheim et al.’s algorithm. t.eachAfter(firstWalk), t.parent.m = -t.z; t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y. if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent. // Compute the left-most, right-most, and depth-most nodes for extents. else { var left = root, right = root, bottom = root; root.eachBefore(function(node) { if (node.x < left.x) left = node; if (node.x > right.x) right = node; if (node.depth > bottom.depth) bottom = node; }); var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1); root.eachBefore(function(node) { node.x = (node.x + tx) * kx; node.y = node.depth * ky; }); } return root; } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is // applied recursively to the children of v, as well as the function // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the // node v is placed to the midpoint of its outermost children. function firstWalk(v) { var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null; if (children) { executeShifts(v); var midpoint = (children[0].z + children[children.length - 1].z) / 2; if (w) { v.z = w.z + separation(v._, w._); v.m = v.z - midpoint; } else { v.z = midpoint; } } else if (w) { v.z = w.z + separation(v._, w._); } v.parent.A = apportion(v, w, v.parent.A || siblings[0]); } // Computes all real x-coordinates by summing up the modifiers recursively. function secondWalk(v) { v._.x = v.z + v.parent.m; v.m += v.parent.m; } // The core of the algorithm. Here, a new subtree is combined with the // previous subtrees. Threads are used to traverse the inside and outside // contours of the left and right subtree up to the highest common level. The // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the // superscript o means outside and i means inside, the subscript - means left // subtree and + means right subtree. For summing up the modifiers along the // contour, we use respective variables si+, si-, so-, and so+. Whenever two // nodes of the inside contours conflict, we compute the left one of the // greatest uncommon ancestors using the function ANCESTOR and call MOVE // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees. // Finally, we add a new thread (if necessary). function apportion(v, w, ancestor) { if (w) { var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift; while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) { vom = nextLeft(vom); vop = nextRight(vop); vop.a = v; shift = vim.z + sim - vip.z - sip + separation(vim._, vip._); if (shift > 0) { moveSubtree(nextAncestor(vim, v, ancestor), v, shift); sip += shift; sop += shift; } sim += vim.m; sip += vip.m; som += vom.m; sop += vop.m; } if (vim && !nextRight(vop)) { vop.t = vim; vop.m += sim - sop; } if (vip && !nextLeft(vom)) { vom.t = vip; vom.m += sip - som; ancestor = v; } } return ancestor; } function sizeNode(node) { node.x *= dx; node.y = node.depth * dy; } tree.separation = function(x) { return arguments.length ? (separation = x, tree) : separation; }; tree.size = function(x) { return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]); }; tree.nodeSize = function(x) { return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null); }; return tree; } function treemapSlice(parent, x0, y0, x1, y1) { var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value; while (++i < n) { node = nodes[i], node.x0 = x0, node.x1 = x1; node.y0 = y0, node.y1 = y0 += node.value * k; } } var phi = (1 + Math.sqrt(5)) / 2; function squarifyRatio(ratio, parent, x0, y0, x1, y1) { var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta; while (i0 < n) { dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node. do sumValue = nodes[i1++].value; while (!sumValue && i1 < n); minValue = maxValue = sumValue; alpha = Math.max(dy / dx, dx / dy) / (value * ratio); beta = sumValue * sumValue * alpha; minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves. for (; i1 < n; ++i1) { sumValue += nodeValue = nodes[i1].value; if (nodeValue < minValue) minValue = nodeValue; if (nodeValue > maxValue) maxValue = nodeValue; beta = sumValue * sumValue * alpha; newRatio = Math.max(maxValue / beta, beta / minValue); if (newRatio > minRatio) { sumValue -= nodeValue; break; } minRatio = newRatio; } // Position and record the row orientation. rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)}); if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1); else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1); value -= sumValue, i0 = i1; } return rows; } var squarify = (function custom(ratio) { function squarify(parent, x0, y0, x1, y1) { squarifyRatio(ratio, parent, x0, y0, x1, y1); } squarify.ratio = function(x) { return custom((x = +x) > 1 ? x : 1); }; return squarify; })(phi); function index$3() { var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero; function treemap(root) { root.x0 = root.y0 = 0; root.x1 = dx; root.y1 = dy; root.eachBefore(positionNode); paddingStack = [0]; if (round) root.eachBefore(roundNode); return root; } function positionNode(node) { var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p; if (x1 < x0) x0 = x1 = (x0 + x1) / 2; if (y1 < y0) y0 = y1 = (y0 + y1) / 2; node.x0 = x0; node.y0 = y0; node.x1 = x1; node.y1 = y1; if (node.children) { p = paddingStack[node.depth + 1] = paddingInner(node) / 2; x0 += paddingLeft(node) - p; y0 += paddingTop(node) - p; x1 -= paddingRight(node) - p; y1 -= paddingBottom(node) - p; if (x1 < x0) x0 = x1 = (x0 + x1) / 2; if (y1 < y0) y0 = y1 = (y0 + y1) / 2; tile(node, x0, y0, x1, y1); } } treemap.round = function(x) { return arguments.length ? (round = !!x, treemap) : round; }; treemap.size = function(x) { return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy]; }; treemap.tile = function(x) { return arguments.length ? (tile = required(x), treemap) : tile; }; treemap.padding = function(x) { return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner(); }; treemap.paddingInner = function(x) { return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingInner; }; treemap.paddingOuter = function(x) { return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop(); }; treemap.paddingTop = function(x) { return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingTop; }; treemap.paddingRight = function(x) { return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingRight; }; treemap.paddingBottom = function(x) { return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingBottom; }; treemap.paddingLeft = function(x) { return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant$8(+x), treemap) : paddingLeft; }; return treemap; } function binary(parent, x0, y0, x1, y1) { var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1); for (sums[0] = sum = i = 0; i < n; ++i) { sums[i + 1] = sum += nodes[i].value; } partition(0, n, parent.value, x0, y0, x1, y1); function partition(i, j, value, x0, y0, x1, y1) { if (i >= j - 1) { var node = nodes[i]; node.x0 = x0, node.y0 = y0; node.x1 = x1, node.y1 = y1; return; } var valueOffset = sums[i], valueTarget = (value / 2) + valueOffset, k = i + 1, hi = j - 1; while (k < hi) { var mid = k + hi >>> 1; if (sums[mid] < valueTarget) k = mid + 1; else hi = mid; } if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k; var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft; if ((x1 - x0) > (y1 - y0)) { var xk = (x0 * valueRight + x1 * valueLeft) / value; partition(i, k, valueLeft, x0, y0, xk, y1); partition(k, j, valueRight, xk, y0, x1, y1); } else { var yk = (y0 * valueRight + y1 * valueLeft) / value; partition(i, k, valueLeft, x0, y0, x1, yk); partition(k, j, valueRight, x0, yk, x1, y1); } } } function sliceDice(parent, x0, y0, x1, y1) { (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1); } var resquarify = (function custom(ratio) { function resquarify(parent, x0, y0, x1, y1) { if ((rows = parent._squarify) && (rows.ratio === ratio)) { var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value; while (++j < m) { row = rows[j], nodes = row.children; for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value; if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value); else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1); value -= row.value; } } else { parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1); rows.ratio = ratio; } } resquarify.ratio = function(x) { return custom((x = +x) > 1 ? x : 1); }; return resquarify; })(phi); function area$1(polygon) { var i = -1, n = polygon.length, a, b = polygon[n - 1], area = 0; while (++i < n) { a = b; b = polygon[i]; area += a[1] * b[0] - a[0] * b[1]; } return area / 2; } function centroid$1(polygon) { var i = -1, n = polygon.length, x = 0, y = 0, a, b = polygon[n - 1], c, k = 0; while (++i < n) { a = b; b = polygon[i]; k += c = a[0] * b[1] - b[0] * a[1]; x += (a[0] + b[0]) * c; y += (a[1] + b[1]) * c; } return k *= 3, [x / k, y / k]; } // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of // the 3D cross product in a quadrant I Cartesian coordinate system (+x is // right, +y is up). Returns a positive value if ABC is counter-clockwise, // negative if clockwise, and zero if the points are collinear. function cross$1(a, b, c) { return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]); } function lexicographicOrder(a, b) { return a[0] - b[0] || a[1] - b[1]; } // Computes the upper convex hull per the monotone chain algorithm. // Assumes points.length >= 3, is sorted by x, unique in y. // Returns an array of indices into points in left-to-right order. function computeUpperHullIndexes(points) { var n = points.length, indexes = [0, 1], size = 2; for (var i = 2; i < n; ++i) { while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside; x0 = x1, y0 = y1; } return inside; } function length$2(polygon) { var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0; while (++i < n) { xa = xb; ya = yb; b = polygon[i]; xb = b[0]; yb = b[1]; xa -= xb; ya -= yb; perimeter += Math.sqrt(xa * xa + ya * ya); } return perimeter; } var slice$4 = [].slice; var noabort = {}; function Queue(size) { this._size = size; this._call = this._error = null; this._tasks = []; this._data = []; this._waiting = this._active = this._ended = this._start = 0; // inside a synchronous task callback? } Queue.prototype = queue.prototype = { constructor: Queue, defer: function(callback) { if (typeof callback !== \"function\") throw new Error(\"invalid callback\"); if (this._call) throw new Error(\"defer after await\"); if (this._error != null) return this; var t = slice$4.call(arguments, 1); t.push(callback); ++this._waiting, this._tasks.push(t); poke$1(this); return this; }, abort: function() { if (this._error == null) abort(this, new Error(\"abort\")); return this; }, await: function(callback) { if (typeof callback !== \"function\") throw new Error(\"invalid callback\"); if (this._call) throw new Error(\"multiple await\"); this._call = function(error, results) { callback.apply(null, [error].concat(results)); }; maybeNotify(this); return this; }, awaitAll: function(callback) { if (typeof callback !== \"function\") throw new Error(\"invalid callback\"); if (this._call) throw new Error(\"multiple await\"); this._call = callback; maybeNotify(this); return this; } }; function poke$1(q) { if (!q._start) { try { start$1(q); } // let the current task complete catch (e) { if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously else if (!q._data) throw e; // await callback errored synchronously } } } function start$1(q) { while (q._start = q._waiting && q._active < q._size) { var i = q._ended + q._active, t = q._tasks[i], j = t.length - 1, c = t[j]; t[j] = end(q, i); --q._waiting, ++q._active; t = c.apply(null, t); if (!q._tasks[i]) continue; // task finished synchronously q._tasks[i] = t || noabort; } } function end(q, i) { return function(e, r) { if (!q._tasks[i]) return; // ignore multiple callbacks --q._active, ++q._ended; q._tasks[i] = null; if (q._error != null) return; // ignore secondary errors if (e != null) { abort(q, e); } else { q._data[i] = r; if (q._waiting) poke$1(q); else maybeNotify(q); } }; } function abort(q, e) { var i = q._tasks.length, t; q._error = e; // ignore active callbacks q._data = undefined; // allow gc q._waiting = NaN; // prevent starting while (--i >= 0) { if (t = q._tasks[i]) { q._tasks[i] = null; if (t.abort) { try { t.abort(); } catch (e) { /* ignore */ } } } } q._active = NaN; // allow notification maybeNotify(q); } function maybeNotify(q) { if (!q._active && q._call) { var d = q._data; q._data = undefined; // allow gc q._call(q._error, d); } } function queue(concurrency) { if (concurrency == null) concurrency = Infinity; else if (!((concurrency = +concurrency) >= 1)) throw new Error(\"invalid concurrency\"); return new Queue(concurrency); } function defaultSource$1() { return Math.random(); } var uniform = (function sourceRandomUniform(source) { function randomUniform(min, max) { min = min == null ? 0 : +min; max = max == null ? 1 : +max; if (arguments.length === 1) max = min, min = 0; else max -= min; return function() { return source() * max + min; }; } randomUniform.source = sourceRandomUniform; return randomUniform; })(defaultSource$1); var normal = (function sourceRandomNormal(source) { function randomNormal(mu, sigma) { var x, r; mu = mu == null ? 0 : +mu; sigma = sigma == null ? 1 : +sigma; return function() { var y; // If available, use the second previously-generated uniform random. if (x != null) y = x, x = null; // Otherwise, generate a new x and y. else do { x = source() * 2 - 1; y = source() * 2 - 1; r = x * x + y * y; } while (!r || r > 1); return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r); }; } randomNormal.source = sourceRandomNormal; return randomNormal; })(defaultSource$1); var logNormal = (function sourceRandomLogNormal(source) { function randomLogNormal() { var randomNormal = normal.source(source).apply(this, arguments); return function() { return Math.exp(randomNormal()); }; } randomLogNormal.source = sourceRandomLogNormal; return randomLogNormal; })(defaultSource$1); var irwinHall = (function sourceRandomIrwinHall(source) { function randomIrwinHall(n) { return function() { for (var sum = 0, i = 0; i < n; ++i) sum += source(); return sum; }; } randomIrwinHall.source = sourceRandomIrwinHall; return randomIrwinHall; })(defaultSource$1); var bates = (function sourceRandomBates(source) { function randomBates(n) { var randomIrwinHall = irwinHall.source(source)(n); return function() { return randomIrwinHall() / n; }; } randomBates.source = sourceRandomBates; return randomBates; })(defaultSource$1); var exponential$1 = (function sourceRandomExponential(source) { function randomExponential(lambda) { return function() { return -Math.log(1 - source()) / lambda; }; } randomExponential.source = sourceRandomExponential; return randomExponential; })(defaultSource$1); function request(url, callback) { var request, event = dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), mimeType, headers = map$1(), xhr = new XMLHttpRequest, user = null, password = null, response, responseType, timeout = 0; // If IE does not support CORS, use XDomainRequest. if (typeof XDomainRequest !== \"undefined\" && !(\"withCredentials\" in xhr) && /^(http(s)?:)?\\/\\//.test(url)) xhr = new XDomainRequest; \"onload\" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); }; function respond(o) { var status = xhr.status, result; if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) { if (response) { try { result = response.call(request, xhr); } catch (e) { event.call(\"error\", request, e); return; } } else { result = xhr; } event.call(\"load\", request, result); } else { event.call(\"error\", request, o); } } xhr.onprogress = function(e) { event.call(\"progress\", request, e); }; request = { header: function(name, value) { name = (name + \"\").toLowerCase(); if (arguments.length < 2) return headers.get(name); if (value == null) headers.remove(name); else headers.set(name, value + \"\"); return request; }, // If mimeType is non-null and no Accept header is set, a default is used. mimeType: function(value) { if (!arguments.length) return mimeType; mimeType = value == null ? null : value + \"\"; return request; }, // Specifies what type the response value should take; // for instance, arraybuffer, blob, document, or text. responseType: function(value) { if (!arguments.length) return responseType; responseType = value; return request; }, timeout: function(value) { if (!arguments.length) return timeout; timeout = +value; return request; }, user: function(value) { return arguments.length < 1 ? user : (user = value == null ? null : value + \"\", request); }, password: function(value) { return arguments.length < 1 ? password : (password = value == null ? null : value + \"\", request); }, // Specify how to convert the response content to a specific type; // changes the callback value on \"load\" events. response: function(value) { response = value; return request; }, // Alias for send(\"GET\", …). get: function(data, callback) { return request.send(\"GET\", data, callback); }, // Alias for send(\"POST\", …). post: function(data, callback) { return request.send(\"POST\", data, callback); }, // If callback is non-null, it will be used for error and load events. send: function(method, data, callback) { xhr.open(method, url, true, user, password); if (mimeType != null && !headers.has(\"accept\")) headers.set(\"accept\", mimeType + \",*/*\"); if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); }); if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType); if (responseType != null) xhr.responseType = responseType; if (timeout > 0) xhr.timeout = timeout; if (callback == null && typeof data === \"function\") callback = data, data = null; if (callback != null && callback.length === 1) callback = fixCallback(callback); if (callback != null) request.on(\"error\", callback).on(\"load\", function(xhr) { callback(null, xhr); }); event.call(\"beforesend\", request, xhr); xhr.send(data == null ? null : data); return request; }, abort: function() { xhr.abort(); return request; }, on: function() { var value = event.on.apply(event, arguments); return value === event ? request : value; } }; if (callback != null) { if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback); return request.get(callback); } return request; } function fixCallback(callback) { return function(error, xhr) { callback(error == null ? xhr : null); }; } function hasResponse(xhr) { var type = xhr.responseType; return type && type !== \"text\" ? xhr.response // null on error : xhr.responseText; // \"\" on error } function type$1(defaultMimeType, response) { return function(url, callback) { var r = request(url).mimeType(defaultMimeType).response(response); if (callback != null) { if (typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback); return r.get(callback); } return r; }; } var html = type$1(\"text/html\", function(xhr) { return document.createRange().createContextualFragment(xhr.responseText); }); var json = type$1(\"application/json\", function(xhr) { return JSON.parse(xhr.responseText); }); var text = type$1(\"text/plain\", function(xhr) { return xhr.responseText; }); var xml = type$1(\"application/xml\", function(xhr) { var xml = xhr.responseXML; if (!xml) throw new Error(\"parse error\"); return xml; }); function dsv$1(defaultMimeType, parse) { return function(url, row, callback) { if (arguments.length < 3) callback = row, row = null; var r = request(url).mimeType(defaultMimeType); r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; }; r.row(row); return callback ? r.get(callback) : r; }; } function responseOf(parse, row) { return function(request$$1) { return parse(request$$1.responseText, row); }; } var csv$1 = dsv$1(\"text/csv\", csvParse); var tsv$1 = dsv$1(\"text/tab-separated-values\", tsvParse); var array$2 = Array.prototype; var map$3 = array$2.map; var slice$5 = array$2.slice; var implicit = {name: \"implicit\"}; function ordinal(range) { var index = map$1(), domain = [], unknown = implicit; range = range == null ? [] : slice$5.call(range); function scale(d) { var key = d + \"\", i = index.get(key); if (!i) { if (unknown !== implicit) return unknown; index.set(key, i = domain.push(d)); } return range[(i - 1) % range.length]; } scale.domain = function(_) { if (!arguments.length) return domain.slice(); domain = [], index = map$1(); var i = -1, n = _.length, d, key; while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d)); return scale; }; scale.range = function(_) { return arguments.length ? (range = slice$5.call(_), scale) : range.slice(); }; scale.unknown = function(_) { return arguments.length ? (unknown = _, scale) : unknown; }; scale.copy = function() { return ordinal() .domain(domain) .range(range) .unknown(unknown); }; return scale; } function band() { var scale = ordinal().unknown(undefined), domain = scale.domain, ordinalRange = scale.range, range$$1 = [0, 1], step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5; delete scale.unknown; function rescale() { var n = domain().length, reverse = range$$1[1] < range$$1[0], start = range$$1[reverse - 0], stop = range$$1[1 - reverse]; step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2); if (round) step = Math.floor(step); start += (stop - start - step * (n - paddingInner)) * align; bandwidth = step * (1 - paddingInner); if (round) start = Math.round(start), bandwidth = Math.round(bandwidth); var values = sequence(n).map(function(i) { return start + step * i; }); return ordinalRange(reverse ? values.reverse() : values); } scale.domain = function(_) { return arguments.length ? (domain(_), rescale()) : domain(); }; scale.range = function(_) { return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice(); }; scale.rangeRound = function(_) { return range$$1 = [+_[0], +_[1]], round = true, rescale(); }; scale.bandwidth = function() { return bandwidth; }; scale.step = function() { return step; }; scale.round = function(_) { return arguments.length ? (round = !!_, rescale()) : round; }; scale.padding = function(_) { return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner; }; scale.paddingInner = function(_) { return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner; }; scale.paddingOuter = function(_) { return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter; }; scale.align = function(_) { return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align; }; scale.copy = function() { return band() .domain(domain()) .range(range$$1) .round(round) .paddingInner(paddingInner) .paddingOuter(paddingOuter) .align(align); }; return rescale(); } function pointish(scale) { var copy = scale.copy; scale.padding = scale.paddingOuter; delete scale.paddingInner; delete scale.paddingOuter; scale.copy = function() { return pointish(copy()); }; return scale; } function point$1() { return pointish(band().paddingInner(1)); } function constant$9(x) { return function() { return x; }; } function number$2(x) { return +x; } var unit = [0, 1]; function deinterpolateLinear(a, b) { return (b -= (a = +a)) ? function(x) { return (x - a) / b; } : constant$9(b); } function deinterpolateClamp(deinterpolate) { return function(a, b) { var d = deinterpolate(a = +a, b = +b); return function(x) { return x = b ? 1 : d(x); }; }; } function reinterpolateClamp(reinterpolate) { return function(a, b) { var r = reinterpolate(a = +a, b = +b); return function(t) { return t = 1 ? b : r(t); }; }; } function bimap(domain, range, deinterpolate, reinterpolate) { var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1]; if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0); else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1); return function(x) { return r0(d0(x)); }; } function polymap(domain, range, deinterpolate, reinterpolate) { var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1; // Reverse descending domains. if (domain[j] < domain[0]) { domain = domain.slice().reverse(); range = range.slice().reverse(); } while (++i < j) { d[i] = deinterpolate(domain[i], domain[i + 1]); r[i] = reinterpolate(range[i], range[i + 1]); } return function(x) { var i = bisectRight(domain, x, 1, j) - 1; return r[i](d[i](x)); }; } function copy(source, target) { return target .domain(source.domain()) .range(source.range()) .interpolate(source.interpolate()) .clamp(source.clamp()); } // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1]. // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b]. function continuous(deinterpolate, reinterpolate) { var domain = unit, range = unit, interpolate$$1 = interpolateValue, clamp = false, piecewise, output, input; function rescale() { piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap; output = input = null; return scale; } function scale(x) { return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x); } scale.invert = function(y) { return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y); }; scale.domain = function(_) { return arguments.length ? (domain = map$3.call(_, number$2), rescale()) : domain.slice(); }; scale.range = function(_) { return arguments.length ? (range = slice$5.call(_), rescale()) : range.slice(); }; scale.rangeRound = function(_) { return range = slice$5.call(_), interpolate$$1 = interpolateRound, rescale(); }; scale.clamp = function(_) { return arguments.length ? (clamp = !!_, rescale()) : clamp; }; scale.interpolate = function(_) { return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1; }; return rescale(); } function tickFormat(domain, count, specifier) { var start = domain[0], stop = domain[domain.length - 1], step = tickStep(start, stop, count == null ? 10 : count), precision; specifier = formatSpecifier(specifier == null ? \",f\" : specifier); switch (specifier.type) { case \"s\": { var value = Math.max(Math.abs(start), Math.abs(stop)); if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision; return exports.formatPrefix(specifier, value); } case \"\": case \"e\": case \"g\": case \"p\": case \"r\": { if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\"); break; } case \"f\": case \"%\": { if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2; break; } } return exports.format(specifier); } function linearish(scale) { var domain = scale.domain; scale.ticks = function(count) { var d = domain(); return ticks(d[0], d[d.length - 1], count == null ? 10 : count); }; scale.tickFormat = function(count, specifier) { return tickFormat(domain(), count, specifier); }; scale.nice = function(count) { if (count == null) count = 10; var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step; if (stop < start) { step = start, start = stop, stop = step; step = i0, i0 = i1, i1 = step; } step = tickIncrement(start, stop, count); if (step > 0) { start = Math.floor(start / step) * step; stop = Math.ceil(stop / step) * step; step = tickIncrement(start, stop, count); } else if (step < 0) { start = Math.ceil(start * step) / step; stop = Math.floor(stop * step) / step; step = tickIncrement(start, stop, count); } if (step > 0) { d[i0] = Math.floor(start / step) * step; d[i1] = Math.ceil(stop / step) * step; domain(d); } else if (step < 0) { d[i0] = Math.ceil(start * step) / step; d[i1] = Math.floor(stop * step) / step; domain(d); } return scale; }; return scale; } function linear$2() { var scale = continuous(deinterpolateLinear, reinterpolate); scale.copy = function() { return copy(scale, linear$2()); }; return linearish(scale); } function identity$6() { var domain = [0, 1]; function scale(x) { return +x; } scale.invert = scale; scale.domain = scale.range = function(_) { return arguments.length ? (domain = map$3.call(_, number$2), scale) : domain.slice(); }; scale.copy = function() { return identity$6().domain(domain); }; return linearish(scale); } function nice(domain, interval) { domain = domain.slice(); var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t; if (x1 < x0) { t = i0, i0 = i1, i1 = t; t = x0, x0 = x1, x1 = t; } domain[i0] = interval.floor(x0); domain[i1] = interval.ceil(x1); return domain; } function deinterpolate(a, b) { return (b = Math.log(b / a)) ? function(x) { return Math.log(x / a) / b; } : constant$9(b); } function reinterpolate$1(a, b) { return a < 0 ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); } : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); }; } function pow10(x) { return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x; } function powp(base) { return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x) { return Math.pow(base, x); }; } function logp(base) { return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x) { return Math.log(x) / base; }); } function reflect(f) { return function(x) { return -f(-x); }; } function log$1() { var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]), domain = scale.domain, base = 10, logs = logp(10), pows = powp(10); function rescale() { logs = logp(base), pows = powp(base); if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows); return scale; } scale.base = function(_) { return arguments.length ? (base = +_, rescale()) : base; }; scale.domain = function(_) { return arguments.length ? (domain(_), rescale()) : domain(); }; scale.ticks = function(count) { var d = domain(), u = d[0], v = d[d.length - 1], r; if (r = v < u) i = u, u = v, v = i; var i = logs(u), j = logs(v), p, k, t, n = count == null ? 10 : +count, z = []; if (!(base % 1) && j - i < n) { i = Math.round(i) - 1, j = Math.round(j) + 1; if (u > 0) for (; i < j; ++i) { for (k = 1, p = pows(i); k < base; ++k) { t = p * k; if (t < u) continue; if (t > v) break; z.push(t); } } else for (; i < j; ++i) { for (k = base - 1, p = pows(i); k >= 1; --k) { t = p * k; if (t < u) continue; if (t > v) break; z.push(t); } } } else { z = ticks(i, j, Math.min(j - i, n)).map(pows); } return r ? z.reverse() : z; }; scale.tickFormat = function(count, specifier) { if (specifier == null) specifier = base === 10 ? \".0e\" : \",\"; if (typeof specifier !== \"function\") specifier = exports.format(specifier); if (count === Infinity) return specifier; if (count == null) count = 10; var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate? return function(d) { var i = d / pows(Math.round(logs(d))); if (i * base < base - 0.5) i *= base; return i 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) { return field(d) % step === 0; } : function(d) { return interval.count(0, d) % step === 0; }); }; } return interval; } var millisecond = newInterval(function() { // noop }, function(date, step) { date.setTime(+date + step); }, function(start, end) { return end - start; }); // An optimized implementation for this simple case. millisecond.every = function(k) { k = Math.floor(k); if (!isFinite(k) || !(k > 0)) return null; if (!(k > 1)) return millisecond; return newInterval(function(date) { date.setTime(Math.floor(date / k) * k); }, function(date, step) { date.setTime(+date + step * k); }, function(start, end) { return (end - start) / k; }); }; var milliseconds = millisecond.range; var durationSecond$1 = 1e3; var durationMinute$1 = 6e4; var durationHour$1 = 36e5; var durationDay$1 = 864e5; var durationWeek$1 = 6048e5; var second = newInterval(function(date) { date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1); }, function(date, step) { date.setTime(+date + step * durationSecond$1); }, function(start, end) { return (end - start) / durationSecond$1; }, function(date) { return date.getUTCSeconds(); }); var seconds = second.range; var minute = newInterval(function(date) { date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1); }, function(date, step) { date.setTime(+date + step * durationMinute$1); }, function(start, end) { return (end - start) / durationMinute$1; }, function(date) { return date.getMinutes(); }); var minutes = minute.range; var hour = newInterval(function(date) { var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1; if (offset < 0) offset += durationHour$1; date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset); }, function(date, step) { date.setTime(+date + step * durationHour$1); }, function(start, end) { return (end - start) / durationHour$1; }, function(date) { return date.getHours(); }); var hours = hour.range; var day = newInterval(function(date) { date.setHours(0, 0, 0, 0); }, function(date, step) { date.setDate(date.getDate() + step); }, function(start, end) { return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1; }, function(date) { return date.getDate() - 1; }); var days = day.range; function weekday(i) { return newInterval(function(date) { date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7); date.setHours(0, 0, 0, 0); }, function(date, step) { date.setDate(date.getDate() + step * 7); }, function(start, end) { return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1; }); } var sunday = weekday(0); var monday = weekday(1); var tuesday = weekday(2); var wednesday = weekday(3); var thursday = weekday(4); var friday = weekday(5); var saturday = weekday(6); var sundays = sunday.range; var mondays = monday.range; var tuesdays = tuesday.range; var wednesdays = wednesday.range; var thursdays = thursday.range; var fridays = friday.range; var saturdays = saturday.range; var month = newInterval(function(date) { date.setDate(1); date.setHours(0, 0, 0, 0); }, function(date, step) { date.setMonth(date.getMonth() + step); }, function(start, end) { return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12; }, function(date) { return date.getMonth(); }); var months = month.range; var year = newInterval(function(date) { date.setMonth(0, 1); date.setHours(0, 0, 0, 0); }, function(date, step) { date.setFullYear(date.getFullYear() + step); }, function(start, end) { return end.getFullYear() - start.getFullYear(); }, function(date) { return date.getFullYear(); }); // An optimized implementation for this simple case. year.every = function(k) { return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) { date.setFullYear(Math.floor(date.getFullYear() / k) * k); date.setMonth(0, 1); date.setHours(0, 0, 0, 0); }, function(date, step) { date.setFullYear(date.getFullYear() + step * k); }); }; var years = year.range; var utcMinute = newInterval(function(date) { date.setUTCSeconds(0, 0); }, function(date, step) { date.setTime(+date + step * durationMinute$1); }, function(start, end) { return (end - start) / durationMinute$1; }, function(date) { return date.getUTCMinutes(); }); var utcMinutes = utcMinute.range; var utcHour = newInterval(function(date) { date.setUTCMinutes(0, 0, 0); }, function(date, step) { date.setTime(+date + step * durationHour$1); }, function(start, end) { return (end - start) / durationHour$1; }, function(date) { return date.getUTCHours(); }); var utcHours = utcHour.range; var utcDay = newInterval(function(date) { date.setUTCHours(0, 0, 0, 0); }, function(date, step) { date.setUTCDate(date.getUTCDate() + step); }, function(start, end) { return (end - start) / durationDay$1; }, function(date) { return date.getUTCDate() - 1; }); var utcDays = utcDay.range; function utcWeekday(i) { return newInterval(function(date) { date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7); date.setUTCHours(0, 0, 0, 0); }, function(date, step) { date.setUTCDate(date.getUTCDate() + step * 7); }, function(start, end) { return (end - start) / durationWeek$1; }); } var utcSunday = utcWeekday(0); var utcMonday = utcWeekday(1); var utcTuesday = utcWeekday(2); var utcWednesday = utcWeekday(3); var utcThursday = utcWeekday(4); var utcFriday = utcWeekday(5); var utcSaturday = utcWeekday(6); var utcSundays = utcSunday.range; var utcMondays = utcMonday.range; var utcTuesdays = utcTuesday.range; var utcWednesdays = utcWednesday.range; var utcThursdays = utcThursday.range; var utcFridays = utcFriday.range; var utcSaturdays = utcSaturday.range; var utcMonth = newInterval(function(date) { date.setUTCDate(1); date.setUTCHours(0, 0, 0, 0); }, function(date, step) { date.setUTCMonth(date.getUTCMonth() + step); }, function(start, end) { return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12; }, function(date) { return date.getUTCMonth(); }); var utcMonths = utcMonth.range; var utcYear = newInterval(function(date) { date.setUTCMonth(0, 1); date.setUTCHours(0, 0, 0, 0); }, function(date, step) { date.setUTCFullYear(date.getUTCFullYear() + step); }, function(start, end) { return end.getUTCFullYear() - start.getUTCFullYear(); }, function(date) { return date.getUTCFullYear(); }); // An optimized implementation for this simple case. utcYear.every = function(k) { return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) { date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k); date.setUTCMonth(0, 1); date.setUTCHours(0, 0, 0, 0); }, function(date, step) { date.setUTCFullYear(date.getUTCFullYear() + step * k); }); }; var utcYears = utcYear.range; function localDate(d) { if (0"}],"posts":[{"title":"t-sne之初体验","slug":"t-sne_how_use","date":"2018-07-05T17:00:00.000Z","updated":"2018-07-06T16:46:20.746Z","comments":true,"path":"2018/07/06/t-sne_how_use/","link":"","permalink":"https://www.xunhanliu.top/2018/07/06/t-sne_how_use/","excerpt":"","text":"t-sen第一贱开锋1、简介 原文链接&emsp;&emsp;t-sen（非线性）在2008年首次被 van der Maaten and Hinton in 2008 [1] 引入，在机器学习领域应用很广泛。它能把多维数据映射到2维数据，从而在二维平面上显示（分别对应直角坐标系的x,y。此时横纵坐标是无意义的。例如，x不是某几个维度的线性组合，所以没法解释x轴表示什么意义。其他的降维方法，降维至2维平面上也可以这样显示）。当参数调整不合适的时候，整个图像容易被误读。&emsp;&emsp;这里主要关注它的参数：“perplexity”。这个参数从某种意义上来说，是对邻居点的猜测。一般取55到50。注：t-sen每次输出的图像都是不固定。 #tray-container { width: 100%; position: fixed; top: 0; left: 0; z-index: 100; top: -410px; transition: top 0.3s; } #tray { position: relative; border: 2px solid steelblue; background: white; padding: 24px 24px 60px 24px; box-shadow: 0px 2px 24px rgba(0, 0, 0, 0.2); box-sizing: border-box; margin: 0 auto; height: 380px; display: flex; justify-content: center; max-width: 700px; border-radius: 4px; } #tray-container.modal { top: -4px; } #tray-content { width: 55%; height: 100%; font-size: 12px; position: relative; top: -12px; } #tray-content canvas { width: 100%; } #tray-options { padding-left: 36px; font-size: 13px; line-height: 1.5em; height: 100%; width: 45%; } #tray-options #tray-controls { margin-bottom: 24px; display: flex; align-items: center; } #tray-controls button { cursor: pointer; outline: none; border-radius: 50%; background: steelblue; color: white; width: 48px; height: 48px; border: none; margin-right: 12px; } #tray-controls .play-pause i { display: none; font-size: 30px; } #tray-controls .play-pause.paused i:nth-child(1) { display: block; } #tray-controls .play-pause.playing i:nth-child(2) { display: block; } #tray-steps-display { text-align: center; width: 48px; font-size: 15px; } #tray input { margin-bottom: 12px; margin-left: -2px; } #tray-data-sliders { } #tray-tsne-sliders { } #tray-close { cursor: pointer; outline: none; background: white; border: none; text-align: center; position: absolute; bottom: 0; width: 100%; padding: 6px 0; background: #f0f4f5; opacity: 0.6; color: steelblue; left: 0; } #tray-close:hover { opacity: 1; } play_arrow pause refresh Step: expand_less // This depends on playground.js having setup the GLOBAL object function runTrayState() { // Set up t-SNE and start it running. var state = GLOBALS.trayState; var points = state.demo.generator.apply(null, state.demoParams); var canvas = d3.select(\"#tray-content canvas\").node() // if there was already a playground demo going, lets destroy it and make a new one if (GLOBALS.trayDemo) { GLOBALS.trayDemo.destroy(); delete GLOBALS.trayDemo; } GLOBALS.trayDemo = demoMaker(points, canvas, state, function (step) { d3.select(\"#tray-controls .step\").text(step); if (step >= state.stepLimit && !GLOBALS.trayUnpausedBefore) { setTrayRunning(false) } }) GLOBALS.trayUnpausedBefore = false; setTrayRunning(true); } function updateTraySliders() { // we regenerate all the sliders from scratch // we modify the global tray state when a slider is modified var state = GLOBALS.trayState; var dataSliders = d3.select('#tray-data-sliders'); dataSliders.html(''); state.demo.options.map(function (option, i) { var value = state.demoParams[i]; var slider = makeTraySlider(dataSliders.node(), option.name, option.min, option.max, value, function () { // when this one updates we change the appropriate state GLOBALS.trayState.demoParams[i] = +slider.value runTrayState(); }); }); var tsneSliders = d3.select('#tray-tsne-sliders'); tsneSliders.html(''); var perpSlider = makeTraySlider(tsneSliders.node(), \"Perplexity\", 1, 100, state.perplexity, function () { GLOBALS.trayState.perplexity = perpSlider.value runTrayState(); }); var epsSlider = makeTraySlider(tsneSliders.node(), \"Epsilon\", 1, 20, state.epsilon, function () { GLOBALS.trayState.epsilon = epsSlider.value runTrayState(); }); } function makeTraySlider(container, name, min, max, start, changeCallback) { var dis = d3.select(container) dis.append(\"span\").classed(\"slider-label-\" + name, true) .text(name + ' ') var value = dis.append(\"span\").classed(\"slider-value-\" + name, true) .text(start) var slider = dis.append(\"input\") .attr(\"type\", \"range\") .attr(\"min\", min) .attr(\"max\", max) .attr(\"value\", start) .on(\"change\", changeCallback) .on(\"input\", function () { value.text(slider.node().value); }) return slider.node(); } /* Activate the tray */ function updateStateFromFigure(figure, example, el) { var y = el.getBoundingClientRect().top; var demo = demosByName[figure.dataset]; var state = { demo: demos[demo.index], demoParams: figure.params.map(function (d) { return d }), perplexity: example.perplexity, epsilon: example.epsilon, stepLimit: example.step } GLOBALS.trayState = state; runTrayState() updateTraySliders() d3.select(\"#tray-container\").classed(\"modal\", true) GLOBALS.trayOpen = true; } d3.select(\"body\").on(\"keydown\", function () { if (d3.event.keyCode === 27) { setTrayRunning(false) d3.select(\"#tray-container\").classed(\"modal\", false); d3.selectAll(\".runner\").classed(\"selected\", false); } }) d3.select(\"#tray-close\").on(\"click\", function () { setTrayRunning(false); GLOBALS.trayOpen = false; d3.select(\"#tray-container\").classed(\"modal\", false) d3.selectAll(\".runner\").classed(\"selected\", false); }) /* Tray Controls */ var trayPlay = d3.select(\"#tray-controls .play-pause\") function setTrayRunning(r) { GLOBALS.running = r; if (GLOBALS.running) { GLOBALS.trayDemo.unpause(); trayPlay .classed(\"playing\", true) .classed(\"paused\", false); } else { GLOBALS.trayDemo.pause(); trayPlay .classed(\"playing\", false) .classed(\"paused\", true); } } // Hook up play / pause / restart buttons. trayPlay.on(\"click\", function () { GLOBALS.trayUnpausedBefore = true; setTrayRunning(!GLOBALS.running); }); var trayRestart = d3.select(\"#tray-controls .restart\") .on(\"click\", function () { runTrayState(); }) d3.select(window).on(\"scroll.tray\", function () { if (GLOBALS.trayOpen) { if (scrollY < 1000) { setTrayRunning(false); GLOBALS.trayOpen = false; d3.select(\"#tray-container\").classed(\"modal\", false); d3.selectAll(\".runner\").classed(\"selected\", false); } } }); /* Tray sliders */ #playground { overflow: hidden; font-family: 'Open Sans', sans-serif; border-top: 1px solid rgba(0, 0, 0, 0.1); /*border-bottom: 1px solid rgba(0, 0, 0, 0.1);*/ margin-top: 36px; padding: 36px 0 0 0; /*background: #fcfcfc;*/ z-index: 1000; } #playground * { box-sizing: border-box; } #playground.modal { position: fixed; left: 10px; right: 10px; top: 50px; } /* Playground Canvas */ #playground-canvas { float: left; width: 55%; } #playground-canvas canvas { width: 100%; } /* Data Menu */ #data-menu { /*float: left;*/ /*width: 25%*/ width: 40%; float: left; margin-bottom: 24px; overflow: hidden; margin-left: 5%; } #data-menu .demo-data { cursor: pointer; position: relative; font-size: 10px; line-height: 1.2em; box-sizing: border-box; float: left; margin: 2px; padding: 4px; width: calc(33% - 4px); background: white; border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 4px; box-shadow: 0 0 3px rgba(0, 0, 0, 0.08); } @media (min-width: 480px) { #data-menu .demo-data { width: calc(25% - 8px); padding: 8px; margin: 4px; } } @media (min-width: 768px) { #data-menu .demo-data { width: calc(16.5% - 8px); padding: 8px; margin: 4px; } } #data-menu .demo-data:hover { border: 1px solid rgba(0, 0, 0, 0.2); } #data-menu .demo-data.selected::after { content: \"\"; border: 2px solid rgba(70, 130, 180, 0.8); width: 100%; height: 100%; position: absolute; top: 0; left: 0; box-sizing: border-box; border-radius: 4px; } #data-menu .demo-data span { display: none; } #data-menu .demo-data:hover canvas { opacity: 1; } #data-menu .demo-data canvas { width: 100%; opacity: 0.3; } #data-menu .demo-data.selected canvas { opacity: 1; } /* Data Details */ #data-details { position: relative; } @media (min-width: 768px) { #data-details { width: 40%; float: right; } } #data-details #data-controls { width: 40%; float: right; position: relative; overflow: hidden; font-size: 13px; } @media (min-width: 768px) { #data-details #data-controls { width: 50%; margin-right: 10%; float: left; } } #data-details #play-controls { margin-bottom: 18px; overflow: hidden; position: relative; } #data-details #play-controls button { cursor: pointer; outline: none; border-radius: 50%; background: steelblue; color: white; width: 25%; margin-right: 5%; padding-top: 25%; padding-bottom: 0; border: none; float: left; position: relative; } #play-controls i { display: block; position: absolute; top: 50%; left: 0; width: 100%; height: 36px; font-size: 24px; line-height: 0; } @media (min-width: 768px) { #play-controls i { font-size: 30px; } } #play-controls #play-pause i { display: none; position: absolute; } #play-controls #play-pause.paused i:nth-child(1) { display: block; } #play-controls #play-pause.playing i:nth-child(2) { display: block; } #steps-display { float: left; text-align: center; width: 25%; line-height: 1.5em; font-size: 13px; } @media (min-width: 1024px) { #steps-display { font-size: 16px; line-height: 1.6em; } } #data-details #data-description { width: 50%; margin-right: 10%; float: right; font-size: 14px; line-height: 1.6em; } @media (min-width: 768px) { #data-details #data-description { width: 40%; float: left; margin-right: 0; } } /* Options */ #data-details #options { float: left; padding-left: 36px; font-size: 13px; line-height: 1.5em; width: 45%; } #data-details input { display: block; width: 100%; margin: 8px 0 16px 0; } #options #data-options { width: 45%; margin-left: 4px; } #options #tsne-options { width: 45%; margin-left: 4px; } #data-details #share { margin-top: 8px; display: block; color: rgba(0, 0, 0, 0.4); text-decoration: none; font-size: 12px; } #data-details #share:hover { text-decoration: underline; } #data-details #share i { line-height: 0px; position: relative; top: 7px; } play_arrowpause refresh Step link Share this view 2、初步体验perplexity参数和step参数 &emsp;&emsp;上图由于perplexity参数的不同，呈现出不同的结果（每个图都执行了5000次迭代）。最重要的是在它们达到稳定状态的时候，如何解释！ &emsp;&emsp;上图的perplexity都是 30，而step分别是：10、20、60、120、1000。没有固定的步数，不同的数据集需要不同的迭代次数来收敛。不同的数据集可能聚合成相似的结果。 3、簇的大小无意义 &emsp;&emsp;想一下这个问题：有两簇数据，它们的标准差不一样，是不是意味着标准差越小，簇越小？ &emsp;&emsp;上图中，一个簇的分散程度是另一个簇的10倍（点数应该是一样的）。调整perplexity，结果如上。结论是：簇的大小无意义。 4、簇之间的距离可能无意义 &emsp;&emsp;问题：距离越近是不是关系越强？ &emsp;&emsp;上图中初始点是3簇，它们均有50点，均满足高斯分布。一对的距离是另一对的5倍。&emsp;&emsp;上图实验结果如下：perplexity=50的时候，几何结构非常好。&lt;50的时候，它们间距都差不多。=100的时候，其中一个簇非常小。=50的时候，结果非常“理想”，是不是意味着设置成50，我们总能看到好的结果？&emsp;&emsp;Sadly, no！ 如果我们增加了点数，就需要增加perplexity进行补偿。下面这个实验吧点数增加到200。 5、随机点的结果并不总是随机的 &emsp;&emsp;一个典型的陷阱是，你在真正的随机数据中看到了模式。下面一个实验是：500个服从单位高斯分布的点，数据集是100维的。下面的original图是前两维数据的映射。 &emsp;&emsp;perplexity=2的时候，呈现戏剧性的聚类，如果就此发现了数据结构，你可能认为自己中了头彩！&emsp;&emsp;从上面所有的实验可以看出perplexity比较低的时候可能会导致这类的分布。识别这些欺骗性的块是识别t-SNE图的一项重要部分。事实上，上图这些特征非常接近于球面上的均匀分布：均匀分布，在点之间的空间大致相等。看到这，t-sne可能比所有线性映射都更精确。 6、有时，你会看到一些形状 &emsp;&emsp;让我们看一下在50维空间中与轴对齐的高斯分布，在这里，坐标i的标准偏差是1/i。也就是说，我们看到的是一个稍长的椭球点云。 &emsp;&emsp;从上图的结果可以看到，perplexity足够大的时候，稍长的形状很容易看到。但=2的时候，无意义的簇开始占主导。有时候，在特定的perplexity，可以看到特定的形状。&emsp;&emsp;下图的数据是2维平面上75点的两簇数据。平行线排列，有一点噪声。 &emsp;&emsp;线条弯曲解释：t-sne尝试扩大数据的密集区域。因为簇的中间区域比边缘区域有更大的密度，t-sne会放大这个特征。 7、拓扑数据，你可能需要更多的图 &emsp;&emsp;一个典型的拓扑特征是包含。下图的数据源是：两组50维的数据，各有70点。它们都是从关于原点对称的高斯分布中取样的。但是，一个数据点的分布是另一个的50倍。“小”分布实际上包含在大的分布中。 &emsp;&emsp;perplexity=30的时候，内群的大小被过分夸大。perplexity=50的时候，外群变成了一个圆一样的结构，这个图试图描述所有的点都与内群的距离相同的事实（实际不是如此）。如果单独看外群，可能会认为它是一个一维的结构。但是更复杂的拓扑结构呢？&emsp;&emsp;下图原始结构是一个俩环相互嵌套的结构。perplexity比较小的时候，两环分离了！ &emsp;&emsp;下图是一个三叶草结构的数据。 &emsp;&emsp;下图是三叶草结构perplexity=2的5次运行结果。（正如前面所说，t-sne每次运行，可能得到的结果都不一样，即使设置的参数一样） >&emsp;&emsp;下图是三叶草结构perplexity=50的5次运行结果。（可以看到，perplexity不能设置得太小） 8、结论 &emsp;&emsp;tsen灵活性强，能经常发现其他降维方法发现不了的特征。 .tsne-group { overflow: visible; display: -webkit-flex; display: flex; flex-direction: column; margin-top: 36px; margin-bottom: 36px; } @media (min-width: 640px) { .tsne-group { -webkit-flex-direction: row; flex-direction: row; } } .tsne-group .original, .tsne-group .runner { box-sizing: border-box; -webkit-flex-grow: 1; flex-grow: 1; position: relative; display: -webkit-flex; display: flex; margin-bottom: 12px; } .tsne-group .original { position: relative; border-bottom: 1px solid rgba(0, 0, 0, 0.1); padding-bottom: 12px; } @media (min-width: 640px) { .tsne-group .original, .tsne-group .runner { display: block; width: 100%; margin-bottom: 0; } .tsne-group .original { margin-left: 0; padding-right: 12px; border-right: 1px solid rgba(0, 0, 0, 0.1); border-bottom: none; padding-bottom: 0; } .tsne-group .runner { margin-left: 12px; } } .tsne-group .runner.no-click { cursor: default; } .runner.clickable { cursor: pointer; } .runner.clickable:hover .image { box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08); } .runner:hover i { opacity: 1; } .runner.selected i { opacity: 1; } .runner i { font-size: 30px; position: absolute; top: 1px; left: 1px; background-color: hsla(207, 44%, 79%, 0.8); color: steelblue; border-radius: 4px; opacity: 0; transition: opacity 0.3s; line-height: 0; width: 150px; padding: 75px 0; text-align: center; } @media (min-width: 640px) { .runner i { width: 100%; padding: 50% 0; } } .runner.selected .image::after { content: \"\"; border: 2px solid rgba(70, 130, 180, 1); width: 100%; height: 100%; position: absolute; top: 0; box-sizing: border-box; border-radius: 4px; z-index: 10; } .tsne-group .image { border: 1px solid rgba(0, 0, 0, 0.1); border-radius: 4px; box-shadow: 0 0 6px rgba(0, 0, 0, 0.08); width: 150px; padding-top: 150px; background: white; position: relative; transition: border-color 0.3s, box-shadow 0.3s; margin-right: 12px; } @media (min-width: 640px) { .tsne-group .image { width: 100%; padding-top: 100%; margin-right: 0; } } .tsne-group .original .image { box-shadow: none; } .tsne-group .image img { position: absolute; top: 5%; left: 5%; width: 90%; } .tsne-group h3.caption { font-size: 15px; margin-top: 12px; } .tsne-group .caption { font-size: 12px; line-height: 1.6em; margin-top: 12px; width: 100px; } @media (min-width: 640px) { .tsne-group .caption, .tsne-group h3.caption { margin-top: 8px; width: 100%; } } (function () { var format = d3.format(\",\"); d3.selectAll(\".tsne-group\").data(figures, function (d) { if (!d) return this.dataset.id; return d.id }) .each(generateFigure) function generateFigure(figure) { var FIGURE = figure.id var dis = d3.select(this) var original = dis.append(\"div\").classed(\"original\", true) original.append(\"div\") .classed(\"image\", true) .append(\"img\") .classed(\"tsne-plot\", true) .attr(\"src\", \"./figure_\" + FIGURE + \"_\" + \"original.png\"); original.append(\"h3\").classed(\"caption\", true).text(\"Original\") // examples var runners = dis.selectAll(\".runner\").data(figure.examples) .enter().append(\"div\").classed(\"runner\", true) if (!figure.noclick) { runners .classed(\"clickable\", true) .on(\"click\", function (d) { d3.selectAll(\".runner\").classed(\"selected\", false) updateStateFromFigure(figure, d, this); d3.select(this).classed(\"selected\", true) }); } else { runners.classed(\"no-click\", true) } runners.append(\"div\") .classed(\"image\", true) .append(\"img\") .attr(\"src\", function (d, i) { return \"./figure_\" + FIGURE + \"_\" + d.id + \".png\" }); if (!figure.noclick) { runners.append(\"i\") .classed(\"material-icons\", true) .text(\"open_in_browser\") } var caption = runners.append(\"div\").classed(\"caption\", true); caption.append(\"div\").text(function (d) { return \"Perplexity: \" + format(d.perplexity); }) caption.append(\"div\").text(function (d) { return \"Step: \" + format(d.step); }) } })() dt-cite { color: hsla(206, 90%, 20%, 0.7); } dt-cite .citation-number { cursor: default; white-space: nowrap; font-family: -apple-system, BlinkMacSystemFont, \"Roboto\", Helvetica, sans-serif; font-size: 75%; color: hsla(206, 90%, 20%, 0.7); display: inline-block; line-height: 1.1em; text-align: center; position: relative; top: -2px; margin: 0 2px; } figcaption dt-cite .citation-number { font-size: 11px; font-weight: normal; top: -2px; line-height: 1em; } Visualizing data using t-SNE [PDF]L.v.d. Maaten, G. Hinton.Journal of Machine Learning Research, Vol 9(Nov), pp. 2579—2605. 2008. function nodeFromString(str) { var div = document.createElement(\"div\"); div.innerHTML = str; return div.firstChild; } function make_hover_css(pos) { var pretty = window.innerWidth > 600; var padding = pretty ? 18 : 12; var outer_padding = pretty ? 18 : 0; var bbox = document.querySelector(\"body\").getBoundingClientRect(); var left = pos[0] - bbox.left, top = pos[1] - bbox.top; var width = Math.min(window.innerWidth - 2 * outer_padding, 648); left = Math.min(left, window.innerWidth - width - outer_padding); width = width - 2 * padding; return (`position: absolute; background-color: #FFF; opacity: 0.95; max-width: ${width}px; top: ${top}px; left: ${left}px; border: 1px solid rgba(0, 0, 0, 0.25); padding: ${padding}px; border-radius: ${pretty ? 3 : 0}px; box-shadow: 0px 2px 10px 2px rgba(0, 0, 0, 0.2); z-index: ${1e6};`); } function DtHoverBox(div_id) { this.div = document.querySelector(\"#\" + div_id); this.visible = false; this.bindDivEvents(); DtHoverBox.box_map[div_id] = this; } DtHoverBox.box_map = {}; DtHoverBox.get_box = function get_box(div_id) { if (div_id in DtHoverBox.box_map) { return DtHoverBox.box_map[div_id]; } else { return new DtHoverBox(div_id); } } DtHoverBox.prototype.show = function show(pos) { this.visible = true; this.div.setAttribute(\"style\", make_hover_css(pos)); for (var box_id in DtHoverBox.box_map) { var box = DtHoverBox.box_map[box_id]; if (box != this) box.hide(); } } DtHoverBox.prototype.showAtNode = function showAtNode(node) { var bbox = node.getBoundingClientRect(); this.show([bbox.right, bbox.bottom]); } DtHoverBox.prototype.hide = function hide() { this.visible = false; if (this.div) this.div.setAttribute(\"style\", \"display:none\"); if (this.timeout) clearTimeout(this.timeout); } DtHoverBox.prototype.stopTimeout = function stopTimeout() { if (this.timeout) clearTimeout(this.timeout); } DtHoverBox.prototype.extendTimeout = function extendTimeout(T) { //console.log(\"extend\", T) var this_ = this; this.stopTimeout(); this.timeout = setTimeout(function () { this_.hide(); }.bind(this), T); } // Bind events to a link to open this box DtHoverBox.prototype.bind = function bind(node) { if (typeof node == \"string\") { node = document.querySelector(node); } node.addEventListener(\"mouseover\", function () { if (!this.visible) this.showAtNode(node); this.stopTimeout(); }.bind(this)); node.addEventListener(\"mouseout\", function () { this.extendTimeout(250); }.bind(this)); node.addEventListener(\"touchstart\", function (e) { if (this.visible) { this.hide(); } else { this.showAtNode(node); } // Don't trigger body touchstart event when touching link e.stopPropagation(); }.bind(this)); } DtHoverBox.prototype.bindDivEvents = function bindDivEvents() { // For mice, same behavior as hovering on links this.div.addEventListener(\"mouseover\", function () { if (!this.visible) this.showAtNode(node); this.stopTimeout(); }.bind(this)); this.div.addEventListener(\"mouseout\", function () { this.extendTimeout(250); }.bind(this)); // Don't trigger body touchstart event when touching within box this.div.addEventListener(\"touchstart\", function (e) { e.stopPropagation(); }); // Close box when touching outside box document.body.addEventListener(\"touchstart\", function () { this.hide(); }.bind(this)); } var hover_es = document.querySelectorAll(\"span[data-hover-ref]\"); hover_es = [].slice.apply(hover_es); hover_es.forEach(function (e, n) { var ref_id = e.getAttribute(\"data-hover-ref\"); DtHoverBox.get_box(ref_id).bind(e); })","categories":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/tags/test/"}]},{"title":"test","slug":"test","date":"2018-07-03T16:58:20.000Z","updated":"2018-07-05T14:24:16.394Z","comments":true,"path":"2018/07/04/test/","link":"","permalink":"https://www.xunhanliu.top/2018/07/04/test/","excerpt":"","text":"测试图片链接连接为：&lt;%- url_for(post.path) %&gt;连接1为：&lt;%- url_for(path) %&gt;连接2为：&lt;%- url_for(page.path) %&gt;ssss","categories":[{"name":"mCat1","slug":"mCat1","permalink":"https://www.xunhanliu.top/categories/mCat1/"}],"tags":[{"name":"mtag1","slug":"mtag1","permalink":"https://www.xunhanliu.top/tags/mtag1/"},{"name":"mtag2","slug":"mtag2","permalink":"https://www.xunhanliu.top/tags/mtag2/"}]},{"title":"MiHo-主题安装和配置详情","slug":"installation-configuration","date":"2017-07-31T16:00:00.000Z","updated":"2018-07-05T03:07:16.441Z","comments":true,"path":"2017/08/01/installation-configuration/","link":"","permalink":"https://www.xunhanliu.top/2017/08/01/installation-configuration/","excerpt":"","text":"一. 主题简介&emsp;&emsp;MiHo 是一款单栏响应式的Hexo主题；基于 Hexo 3.0+ 制作，兼容移动端浏览；主题的代码托管在GitHub上，欢迎Star和Fork；如遇到问题或发表建议，可以提Issues，也可以在博客中留言给我，另外,喜欢的话不妨给个 Star。 二. 安装2.1 安装主题1$ git clone https://github.com/WongMinHo/hexo-theme-miho.git themes/miho MiHo 主题需要Hexo 3.0或以上版本，请先升级。 2.2 更新12cd themes/mihogit pull 2.3 依赖安装如下依赖如果已经安装，请看配置介绍。 Json-content生成站点文章静态数据，用于站内搜索。1npm install hexo-generator-json-content --save 三. 站点配置站点配置文件_config.yml在hexo根目录下。 3.1 启用主题1`theme: miho` 3.2 网站基本配置以下配置是站点的全局配置，更多配置，请查看123456title: MinHow's Blogsubtitle: 网站副标题description: 专注 WEB 开发的技术博客author: MinHowlanguage: 网站使用的语言timezone: 网站时区 3.3 jsonContent配置详细的配置请查看hexo-generator-json-content123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: false 四. 主题配置编辑主题配置文件，themes/miho/_config.yml。 4.1 属性下面将介绍几个比较重要的配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122# hexo-theme-miho# https://github.com/wongminho/hexo-theme-miho# Favicon of your site | 网站iconfavicon: /favicon.ico# Header# Keywords of your site | 网站关键字keywords: MinHow,MinHow's Blog# Head headline | 头部标题header_title: MinHow's Blog# Head description | 头部描述header_description: 一个专注 WEB 开发的技术博客# Link to your logo | logo地址logo: images/logo.png# Link to your banner_img | 首页banner图地址banner_img: images/banner.jpg# Menu setting | 菜单设置# name: Font Awesome icon | Font Awesome 图标# title: Home Title | 标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出menu: home: title: Home url: / target: false archive: title: Archives url: /archives target: false user: title: About url: /about target: false# Social setting, use to display social information | 社交设置，用来展示社交信息# name: Font Awesome icon | Font Awesome 图标# title: Home Icon title | 图标标题# url: //minhow.com Url, absolute or relative path | 链接，绝对或相对路径# target: true Whether to jump out | 是否跳出social: home: title: MinHow url: //minhow.com target: true github: title: Github url: //github.com/wongminho target: true weibo: title: Weibo url: //weibo.com/WongMinHo target: true twitter: title: Twitter url: //twitter.com/huangminhow target: true #qq: #weixin: #snapchat: #telegram: #mail: #facebook: #google: #linkedin:# Content# Excerpt length | 摘录长度excerpt_length: 190# Excerpt link | 摘录链接excerpt_link: more&gt;&gt;# New window open link | 新窗口打开文章open_new_link: false# Article default cover picture，size：350*150 | 文章默认封面图，尺寸：350*150cover_picture: images/banner.jpg# Open background particles | 开启背景粒子open_bg_particle: true# Open animation in homepage and head | 开启主页及头部动画open_animation: true# Article# Open toc | 是否开启toctoc: true# Open share | 是否开启分享share: true# Style customization | 样式定制style: # Main color tone | 主色调 main_color: '#0cc'# Comments | 评论# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false# Analytics | 分析# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google analytics | google分析google_analytics: false# Footer# Access statistics | “不蒜子”访问量统计access_counter: on: true site_uv: 总访客数： site_pv: 总访问量：# Copyright Information | 版权信息copyright: 2017 MinHow 4.2 文章封面图文章默认封面图，尺寸：350*150，当文章基本配置没有cover_picture时才显示。1cover_picture: images/banner.jpg 4.3 开启背景粒子是否开启背景粒子。1open_bg_particle: true 4.4 开启主页及头部动画是否开启主页及头部动画。1open_animation: true 4.5 评论支持畅言、disqus。1234567# 畅言，输入appid和appkeychangyan_appid: falsechangyan_appkey: false# 友言，输入idyouyan_id: false# disqusdisqus: false 4.6 数据统计支持站长、百度、google三种数据统计，正确填写配置信息即可。123456# 站长分析，输入站点idcnzz_analytics: false# 百度分析，输入key值baidu_analytics: false# google分析google_analytics: false 4.7 文章基本配置123456789101112---title: Hello Worlddate: 2017-06-18categories: Firstauthor: MinHowtags: - First - Secondcover_picture: /images/banner.jpg--- MinHow-This is a summary&lt;!-- more --&gt; 说明： 需要注意tags和摘要的写法，不然首页不能正确显示标签和摘要； cover_picture文章封面图，不填默认显示_config.yml配置的图片。","categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://www.xunhanliu.top/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.xunhanliu.top/tags/博客/"},{"name":"开源项目","slug":"开源项目","permalink":"https://www.xunhanliu.top/tags/开源项目/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-31T16:00:00.000Z","updated":"2018-07-03T19:05:09.545Z","comments":true,"path":"2017/08/01/hello-world/","link":"","permalink":"https://www.xunhanliu.top/2017/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"开源项目","slug":"开源项目","permalink":"https://www.xunhanliu.top/categories/开源项目/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.xunhanliu.top/tags/博客/"},{"name":"开源项目","slug":"开源项目","permalink":"https://www.xunhanliu.top/tags/开源项目/"}]},{"title":"md文件模板+html","slug":"testHtml","date":"2017-07-31T16:00:00.000Z","updated":"2018-07-05T14:12:53.123Z","comments":true,"path":"2017/08/01/testHtml/","link":"","permalink":"https://www.xunhanliu.top/2017/08/01/testHtml/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/tags/test/"}]},{"title":"test_Md+Html","slug":"testMd+Html","date":"2017-07-31T16:00:00.000Z","updated":"2018-07-05T15:05:46.931Z","comments":false,"path":"2017/08/01/testMd+Html/","link":"","permalink":"https://www.xunhanliu.top/2017/08/01/testMd+Html/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 内联style—# 又一个title—2级标题3级标题4级标题外联style","categories":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.xunhanliu.top/tags/test/"}]}]}